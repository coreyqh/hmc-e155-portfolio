[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "E155 Course Website"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification of a simple FPGA design to become familiar with the E155 toolflow. The design contains a seven segment display decoder, a simple digital oscillator, and a few logic gates.\n\n\n\nThe core part of the design is a 4 to 7 bit decoder for controlling a 7 segment display to display the hex value of a 4 bit input signal. This was created using behavioral SystemVerilog code and was verfified with a simple testbench, where the input signal was incremented from 0000 to 1111 and values for each bit of the decoded output was checked against the expected stream of bits. In hindsight, this was likely a convoluted approach to verification, but since the module is just a truth table, using standard test vectors would essentially mean copying the RTL code to see if it matched itself.\nFor the top level module, the seven segment decoder was instantiated alongside a high speed oscillator (HSOSC) to generate a 48 MHz clock. This clock was fed into a digital clock divider where a constant P is added to a 32 bit register on each rising edge of the fast clock, causing the most significant bit to toggle with a frequency given by the following equation:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 32 bits, F = 48 MHz, and f = 2.4 Hz, we can solve for P = 215 to achieve the desired frequency.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the 7:4 decoder, two logic gates, high frequency clock, and clock divider\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the seven LEDs of the seven segment display with current limiting resistors, the three on-board LEDs driven by the design, and the input DIP switches.\n\n\n\nFrom the data sheet the LED display has a voltage drop of roughly 2 volts. Since we are using a 3.3 Volt supply and the FPGA pins have an 8 mA current limit, we can set up the following equation for the minimum current limiting resistor value:\n\\[\nR = \\frac{3.3V - 2V}{8mA} = 165 \\Omega\n\\]\nHowever, to be extra careful not to burn out my LED display, I used a factor of safety of 2 and used 330 Ohm resistors.\n\n\n\n\n\n\n\n\n\nFigure 3: Testbench simulation waveforms from decoder module\n\n\n\n\n\nFigure 4: Successful testbench output from seven segment decoder simulation\n\n\n\n\n\nFigure 5: Testbench Simulation of top level module\n\n\n\n\n\nFigure 6: Successful testbench output from top level simulation\n\n\nThe design was shown to meet all specifications in simulation, except the blinking LED which was tested in hardware.\n\n\n\nThe seven segment display and two gate-driven LEDs responded to input DIP switches in accordance with the design spec\n\n\n\nFigure 7: Photograph of oscilliscope measuring ~2.4Hz LED blinking\n\n\nFigure 7 shows the corrent timing of the blinking LED in hardware.\n\n\n\n\nI was able to set up the E155 toolchain and demonstrate it on this moderately simple lab. I look forward to building experience with this flow on future labs. I spent roughly 15 hours on this lab.\n\n\n\nI gave Microsoft Bing the following prompt to see if it could replicate some of my work:\n“Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nInitally, it gave me the following code:\nmodule led_blinker_2hz (\n    output logic led\n);\n\n    // Internal oscillator output\n    logic clk;\n    logic clk_en;\n\n    // Instantiate the high-frequency oscillator (typically 48 MHz)\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\")  // No division: 48 MHz\n    ) hf_osc_inst (\n        .CLKHFEN(clk_en),\n        .CLKHFPU(clk_en),\n        .CLKHF(clk)\n    );\n\n    // Enable the oscillator\n    initial clk_en = 1'b1;\n\n    // Counter to divide 48 MHz down to 2 Hz\n    // 48,000,000 / 2 = 24,000,000 clock cycles per toggle\n    localparam int COUNT_MAX = 24_000_000;\n    logic [$clog2(COUNT_MAX)-1:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        if (counter == COUNT_MAX - 1) begin\n            counter &lt;= 0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\nThis did not synthesize since it used a different clock generator module, SB_HFOSC. When I asked it to correct the error, it insisted that it was related to a missing package. However, once I changed this module to HSOSC, it synthesized just fine.\nThis prototype made me question the landscape of digital design. It seems that these models have gotten very good at the big picture, and only now struggle with the software specific details."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification of a simple FPGA design to become familiar with the E155 toolflow. The design contains a seven segment display decoder, a simple digital oscillator, and a few logic gates.\n\n\n\nThe core part of the design is a 4 to 7 bit decoder for controlling a 7 segment display to display the hex value of a 4 bit input signal. This was created using behavioral SystemVerilog code and was verfified with a simple testbench, where the input signal was incremented from 0000 to 1111 and values for each bit of the decoded output was checked against the expected stream of bits. In hindsight, this was likely a convoluted approach to verification, but since the module is just a truth table, using standard test vectors would essentially mean copying the RTL code to see if it matched itself.\nFor the top level module, the seven segment decoder was instantiated alongside a high speed oscillator (HSOSC) to generate a 48 MHz clock. This clock was fed into a digital clock divider where a constant P is added to a 32 bit register on each rising edge of the fast clock, causing the most significant bit to toggle with a frequency given by the following equation:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 32 bits, F = 48 MHz, and f = 2.4 Hz, we can solve for P = 215 to achieve the desired frequency.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the 7:4 decoder, two logic gates, high frequency clock, and clock divider\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the seven LEDs of the seven segment display with current limiting resistors, the three on-board LEDs driven by the design, and the input DIP switches.\n\n\n\nFrom the data sheet the LED display has a voltage drop of roughly 2 volts. Since we are using a 3.3 Volt supply and the FPGA pins have an 8 mA current limit, we can set up the following equation for the minimum current limiting resistor value:\n\\[\nR = \\frac{3.3V - 2V}{8mA} = 165 \\Omega\n\\]\nHowever, to be extra careful not to burn out my LED display, I used a factor of safety of 2 and used 330 Ohm resistors.\n\n\n\n\n\n\n\n\n\nFigure 3: Testbench simulation waveforms from decoder module\n\n\n\n\n\nFigure 4: Successful testbench output from seven segment decoder simulation\n\n\n\n\n\nFigure 5: Testbench Simulation of top level module\n\n\n\n\n\nFigure 6: Successful testbench output from top level simulation\n\n\nThe design was shown to meet all specifications in simulation, except the blinking LED which was tested in hardware.\n\n\n\nThe seven segment display and two gate-driven LEDs responded to input DIP switches in accordance with the design spec\n\n\n\nFigure 7: Photograph of oscilliscope measuring ~2.4Hz LED blinking\n\n\nFigure 7 shows the corrent timing of the blinking LED in hardware.\n\n\n\n\nI was able to set up the E155 toolchain and demonstrate it on this moderately simple lab. I look forward to building experience with this flow on future labs. I spent roughly 15 hours on this lab.\n\n\n\nI gave Microsoft Bing the following prompt to see if it could replicate some of my work:\n“Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nInitally, it gave me the following code:\nmodule led_blinker_2hz (\n    output logic led\n);\n\n    // Internal oscillator output\n    logic clk;\n    logic clk_en;\n\n    // Instantiate the high-frequency oscillator (typically 48 MHz)\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\")  // No division: 48 MHz\n    ) hf_osc_inst (\n        .CLKHFEN(clk_en),\n        .CLKHFPU(clk_en),\n        .CLKHF(clk)\n    );\n\n    // Enable the oscillator\n    initial clk_en = 1'b1;\n\n    // Counter to divide 48 MHz down to 2 Hz\n    // 48,000,000 / 2 = 24,000,000 clock cycles per toggle\n    localparam int COUNT_MAX = 24_000_000;\n    logic [$clog2(COUNT_MAX)-1:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        if (counter == COUNT_MAX - 1) begin\n            counter &lt;= 0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\nThis did not synthesize since it used a different clock generator module, SB_HFOSC. When I asked it to correct the error, it insisted that it was related to a missing package. However, once I changed this module to HSOSC, it synthesized just fine.\nThis prototype made me question the landscape of digital design. It seems that these models have gotten very good at the big picture, and only now struggle with the software specific details."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Getting Started\n\n\nFirst Steps into E155\n\n\n\n\n\nAug 29, 2025\n\n\nCorey Hickson\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Corey Hickson is a class of 2026 Engineering Major at Harvey Mudd College with background in design verification and digital design. As a VLSI research fellow with the Clay-Wolkin Fellowship at Harvey Mudd, he has conducted core level functional testing and coverage collection of a RISC-V processor core. While interning at Skyworks Solutions in the summer of 2025, he conducted whole core level formal verification of a different RISC-V processor core. Corey looks forward to the 2025-26 HRL Laboratories engineering clinic project, where he and his team will work towards producing a C program to emulate a mixed analog-digital quantum qubit control board. After graduation, he will return to Skyworks as a Design Verification Engineer 1 to continue his work in formal verification from the past summer."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification process for a time division multiplexed 7-segment display pair.\n\n\n\nThe design uses a single time-multiplexed 7 segment decoder that switches between two sets of hex nibble inputs at 60 Hz. This is done by dividing a 48 MHz clock to 120 Hz, and using this slow clock to drive a toggle flop to divide down to 60 Hz (called the select line). The select line switches between the two inputs and two power pins and the slow clock triggers flops on the output to ensure clean transitions between the two displays\nI did formal verification for this project using SymbiYosys. For this, when synthesizing for formal verification there is an external clock input that takes the place of the slow clock. I proved that a set of design assertions cannot be broken for 30 cycles, and that there is no trace through the design that breaks an assertion on the 1000th cycle, so by interpolating we can declare the design bug free with respect to these assertions.\nFor the slow clock generation, I used the same formula as last week with a different target frequency:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 24 bits, F = 48 MHz, and f = 120 Hz, we can solve for P = 42 to achieve the desired frequency.\nSince this was not covered in formal verification, this portion of the design was verified with a simple testbench simulation.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the single 7:4 decoder, high frequency clock, clock divider, and a few registers and gates\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the two 7-segment displays, 5 additional LEDs, 4 external DIP switches, and 2 PNP transistors.\n\n\n\nFor this lab we had 3 different resistor values to calculate.\nFirst, we needed the current limiting resistors for the single LEDs driven by IO pins on the FPGA. From the FPGA datasheet, the FPGA can ouput 3.3V on an IO pin at a maximum of 8 mA of current. For safety, I aimed for ~3 mA. Red LEDs have a voltage drop of ~1.8V, so we get the following equation:\n\\[\nR = \\frac{3.3V - 1.8V}{3mA} = 500 \\Omega\n\\]\nNext, we have the current limiting resistors for the 7-segment LED arrays. These follow the same general format as the previous calculation, but since there is a voltage drop of ~0.2V between the collector and emitter of the PNP transister, per the datasheet, the calculation becomes the following:\n\\[\nR = \\frac{3.3V - 0.2V - 1.8V}{3mA} = 433 \\Omega\n\\]\nFinally, we have the resistor binding the base of the PNP transistor to the IO pin that powers each 7-segment display. Since the upper voltage is 3.3V going into a silicon diode that connects to the base, the voltage at the base is 0.7V lower or 2.6V. When the pin that is bridged to this terminal by a resistor is low, we wish to limit the current into the pin, so we aim for a large resistor. If we aim for around 3 mA of current, then we get the following equation for R:\n\\[\nR = \\frac{3.3V - 0.7V - 0}{3mA} = 866 \\Omega\n\\]\nTo be extra safe and make use of readily available components, I used 680 Ohms for the current limiting resistors and 1 kOhms for the resistors connected to the PNPs.\n\n\n\n\n\n\n\n\n\nFigure 3: Bounded formal proof results (depth of 30 cycles)\n\n\n\n\n\nFigure 4: Deep formal bug hunt results (checking all ways to reach cycle 1000)\n\n\n\n\n\nFigure 5: Simulation waveforms for clock verification\n\n\n\n\n\nFigure 6: Simulation output for clock verification\n\n\nFormal verification proved that the design met all cycle dependant specifications (based on assumptions about the clock signal), and the simple simulation demonstrated expected behavior of the clock.\n\n\n\nThe input space was sampled at random to check a subset of the design functionality. Additionally, I observed that the two segments did no flicker or bleed into one another, and were reletively bright.\n\n\n\n\nI was able to design a time division multiplexing circuit to have two design elements share a single piece of expensive harware. I brushed up on my synchronous design skills and my ability to formally describe the intended behavior of a sequential design without explicit test cases, as to be able to use formal verification.\nI spent around 15 hours on this lab\n\n\n\nI gave google’s “AI Mode” search engine the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”\nAnd it produced the commented out code in the AI section of the lab repository here. This design has the following structure:\n\n\n\nFigure 7: First AI design netlist viewer\n\n\nThis initially had a minor bug where the dimensions of a logic vector were given after the name. Once this was corrected, the design synthesized without issue.\nNext, I gave a new AI session my files from lab 1 and the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.”\nThis time, there were no issues synthesizing and it produced the following design:\n\n\n\nFigure 7: Second AI design netlist viewer\n\n\nThis is similar to my design for this lab, but without the registers on the output side.\nThis activity led me to question the necessity of the registers I added at the output, as the LLM did not feel the need to add them in its version of the design, which otherwiss lines up with mine. I am again impressed by the ability of LLMs to carry out digital design. I am beginning to wonder if they will come after my Design Verification career…"
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification process for a time division multiplexed 7-segment display pair.\n\n\n\nThe design uses a single time-multiplexed 7 segment decoder that switches between two sets of hex nibble inputs at 60 Hz. This is done by dividing a 48 MHz clock to 120 Hz, and using this slow clock to drive a toggle flop to divide down to 60 Hz (called the select line). The select line switches between the two inputs and two power pins and the slow clock triggers flops on the output to ensure clean transitions between the two displays\nI did formal verification for this project using SymbiYosys. For this, when synthesizing for formal verification there is an external clock input that takes the place of the slow clock. I proved that a set of design assertions cannot be broken for 30 cycles, and that there is no trace through the design that breaks an assertion on the 1000th cycle, so by interpolating we can declare the design bug free with respect to these assertions.\nFor the slow clock generation, I used the same formula as last week with a different target frequency:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 24 bits, F = 48 MHz, and f = 120 Hz, we can solve for P = 42 to achieve the desired frequency.\nSince this was not covered in formal verification, this portion of the design was verified with a simple testbench simulation.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the single 7:4 decoder, high frequency clock, clock divider, and a few registers and gates\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the two 7-segment displays, 5 additional LEDs, 4 external DIP switches, and 2 PNP transistors.\n\n\n\nFor this lab we had 3 different resistor values to calculate.\nFirst, we needed the current limiting resistors for the single LEDs driven by IO pins on the FPGA. From the FPGA datasheet, the FPGA can ouput 3.3V on an IO pin at a maximum of 8 mA of current. For safety, I aimed for ~3 mA. Red LEDs have a voltage drop of ~1.8V, so we get the following equation:\n\\[\nR = \\frac{3.3V - 1.8V}{3mA} = 500 \\Omega\n\\]\nNext, we have the current limiting resistors for the 7-segment LED arrays. These follow the same general format as the previous calculation, but since there is a voltage drop of ~0.2V between the collector and emitter of the PNP transister, per the datasheet, the calculation becomes the following:\n\\[\nR = \\frac{3.3V - 0.2V - 1.8V}{3mA} = 433 \\Omega\n\\]\nFinally, we have the resistor binding the base of the PNP transistor to the IO pin that powers each 7-segment display. Since the upper voltage is 3.3V going into a silicon diode that connects to the base, the voltage at the base is 0.7V lower or 2.6V. When the pin that is bridged to this terminal by a resistor is low, we wish to limit the current into the pin, so we aim for a large resistor. If we aim for around 3 mA of current, then we get the following equation for R:\n\\[\nR = \\frac{3.3V - 0.7V - 0}{3mA} = 866 \\Omega\n\\]\nTo be extra safe and make use of readily available components, I used 680 Ohms for the current limiting resistors and 1 kOhms for the resistors connected to the PNPs.\n\n\n\n\n\n\n\n\n\nFigure 3: Bounded formal proof results (depth of 30 cycles)\n\n\n\n\n\nFigure 4: Deep formal bug hunt results (checking all ways to reach cycle 1000)\n\n\n\n\n\nFigure 5: Simulation waveforms for clock verification\n\n\n\n\n\nFigure 6: Simulation output for clock verification\n\n\nFormal verification proved that the design met all cycle dependant specifications (based on assumptions about the clock signal), and the simple simulation demonstrated expected behavior of the clock.\n\n\n\nThe input space was sampled at random to check a subset of the design functionality. Additionally, I observed that the two segments did no flicker or bleed into one another, and were reletively bright.\n\n\n\n\nI was able to design a time division multiplexing circuit to have two design elements share a single piece of expensive harware. I brushed up on my synchronous design skills and my ability to formally describe the intended behavior of a sequential design without explicit test cases, as to be able to use formal verification.\nI spent around 15 hours on this lab\n\n\n\nI gave google’s “AI Mode” search engine the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”\nAnd it produced the commented out code in the AI section of the lab repository here. This design has the following structure:\n\n\n\nFigure 7: First AI design netlist viewer\n\n\nThis initially had a minor bug where the dimensions of a logic vector were given after the name. Once this was corrected, the design synthesized without issue.\nNext, I gave a new AI session my files from lab 1 and the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.”\nThis time, there were no issues synthesizing and it produced the following design:\n\n\n\nFigure 7: Second AI design netlist viewer\n\n\nThis is similar to my design for this lab, but without the registers on the output side.\nThis activity led me to question the necessity of the registers I added at the output, as the LLM did not feel the need to add them in its version of the design, which otherwiss lines up with mine. I am again impressed by the ability of LLMs to carry out digital design. I am beginning to wonder if they will come after my Design Verification career…"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Getting Started",
    "section": "",
    "text": "This week we had the first 2 lectures for E155, covering course logistics and (System)Verilog syntax and idioms. I was especially exited to cover Verilog since I have become extremely familliar with the subtleties of the Language Reference Manual (LRM) over the past few months (especially the verification specific constructs)."
  },
  {
    "objectID": "posts/first-post.html#week-1-lectures",
    "href": "posts/first-post.html#week-1-lectures",
    "title": "Getting Started",
    "section": "",
    "text": "This week we had the first 2 lectures for E155, covering course logistics and (System)Verilog syntax and idioms. I was especially exited to cover Verilog since I have become extremely familliar with the subtleties of the Language Reference Manual (LRM) over the past few months (especially the verification specific constructs)."
  },
  {
    "objectID": "posts/first-post.html#in-the-lab",
    "href": "posts/first-post.html#in-the-lab",
    "title": "Getting Started",
    "section": "In the Lab",
    "text": "In the Lab\nWhile there were no technical deliverables for this week, I still spent a few hours in the lab soldering all components and connectors to the PCB motherboard. I am not the most skilled at soldering, and I did not have previous experience with surface mounted soldering so this was a bit of a challenge. After much slouching, a considerable amount of solder wick, and a few backwards idodes, I have now finished this task and can move onto lab 1!"
  },
  {
    "objectID": "posts/first-post.html#goal-setting",
    "href": "posts/first-post.html#goal-setting",
    "title": "Getting Started",
    "section": "Goal Setting",
    "text": "Goal Setting\nI am extremely excited to take this class, as I wanted to take it sooner but did not have the time in my schedule. My primary goal is to expand my scope as an electrical engineer beyone ASIC RTL and DV, and into the realm of embedded systems. My secondary goal is to have fun with this class and enjoy my final year at Mudd. I really enjoyed E80 and the E85 microprocessor based labs, so I know that I will enjoy this course now that I have the chance to take it."
  }
]