[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "E155 Course Website"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design of interrupt based firmware to calculate the angular velocity of a DC motor using quadrature encoders\n\n\n\nTo ensure maximum accuracy accross all speeds, we use rising and falling edge interrupts for both quad encoders, and then use the values values of the two quad encoder signals to determine the direction of rotation\n\n\n\nTo find the rotation speed of the motor, I have a variable that stores the number of IRQs that have occured which is incremented in the interrupt handlers for the A and B quad encoder signals. To turn this count into a speed, I have a while loop in my main function that resets the counter and an internal timer, waits for the timer to surpass 1 sample period (200 ms), then does the following calculation to find the number of revolutions per second\n\\[\nM (Pulses) = \\frac{N (Interrupts)}{4 (Interrupts/Pulse)}\n\\]\n\\[\nRPS = \\frac{\\frac{M (Pulses)}{408 (Pulses/Rev)}}{\\frac{P (ms)}{1000 (ms/s)}}\n\\]\nWhere N is the number of interrupts counted, M is the number of pulses, and P is the sample period in milliseconds.\nThis methodology was implemented into a program with the following process flow diagram. \n\n\n\nTo verify the timing calculations above, I used an oscilliscope to measure the period of a quad encoder pulse, and the used the known value of 408 pulses/rev to find the true RPS.\n \n\\[\nRPS = \\frac{F (pulse/s)}{408 (pulse/rev)} = \\frac{462 (pulse/s)}{408 (pulse/rev)} = 1.1326 rev/s\n\\]\nWhile this trace was taken, the output terminal reported an RPS of ~1.15, which is approximately equal to the true value calculated above.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 4: Schematic of motor and quad encoder circuit\n\n\nThe schematic in figure 4 demonstrates the simple wiring for the quad encoder to the motherboard.\n\n\n\n\nThe design accurately displayed the angular speed of the motor and direction of rotation across a wide range of speeds.\nThis lab took roughly 10 hours.\n\n\nTo investigate the advantage of interrupt based timing calculations to polling, I repeated this assignment to use polling instead of interrupts, and in the main while loop toggled a pin to probe the frequency of this sampling.\n\n\n\nFigure 5: Oscilliscope trace of main polling loop\n\n\nSince this pin toggles every time the main while loop cycles, one half period is the sample period for this polling based design. To ensure that polling does not miss any pin transition events, this sample frequency must be at least twice that of the quad encoders (per Shannons Theorem).\nThis means that the maximum pulses per second is 2 times the polling frequency, or 11.62 kHz. Finally, since there are 408 pulses per revolution, the maximum revolutions per second is\n\\[\nRPS \\le \\frac{11620 (pulses/s)}{408 (pulses/rev)} = 28.48 (rev/s)\n\\]\nSo polling should be adequate for the operating range of the motor.\n\n\n\n\nI gave MS Bing the following prompt:\n“Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?”\nAnd it produced the following code:\n\n// --- Initialization ---\nvoid Encoder_Init(void) {\n    // Enable GPIOA and TIM2 clocks\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n\n    // Configure PA0, PA1 as AF1 (TIM2_CH1, TIM2_CH2)\n    GPIOA-&gt;MODER &= ~((3 &lt;&lt; (0*2)) | (3 &lt;&lt; (1*2))); // clear mode\n    GPIOA-&gt;MODER |=  (2 &lt;&lt; (0*2)) | (2 &lt;&lt; (1*2));   // AF mode\n    GPIOA-&gt;AFR[0] |= (1 &lt;&lt; (0*4)) | (1 &lt;&lt; (1*4));   // AF1\n\n    // Configure TIM2 in encoder mode\n    TIM2-&gt;SMCR = TIM_SMCR_SMS_0 | TIM_SMCR_SMS_1;   // Encoder mode 3 (count on both TI1 and TI2)\n    TIM2-&gt;CCMR1 = (1 &lt;&lt; 0) | (1 &lt;&lt; 8);              // CC1S=01, CC2S=01 (inputs)\n    TIM2-&gt;CCER = 0;                                 // Rising edge polarity\n    TIM2-&gt;ARR = 0xFFFFFFFF;                         // Max count\n    TIM2-&gt;CNT = 0;                                  // Reset counter\n\n    // Enable update interrupt\n    TIM2-&gt;DIER |= TIM_DIER_UIE;\n    NVIC_EnableIRQ(TIM2_IRQn);\n\n    // Start timer\n    TIM2-&gt;CR1 |= TIM_CR1_CEN;\n}\n\n// --- Interrupt Handler ---\nvoid TIM2_IRQHandler(void) {\n    if (TIM2-&gt;SR & TIM_SR_UIF) {   // Update interrupt flag\n        TIM2-&gt;SR &= ~TIM_SR_UIF;   // Clear flag\n        // Handle overflow/underflow here\n    }\n}\n\n#define ENCODER_CPR   (PPR * 4)    // Example: 1024 PPR encoder, x4 decoding\n\nvolatile int32_t last_count = 0;\nvolatile float rps = 0.0f;\n\nvoid SysTick_Handler(void) {\n    int32_t current = TIM2-&gt;CNT;\n    int32_t delta = current - last_count;\n    last_count = current;\n\n    // Handle wraparound (TIM2 is 32-bit, so usually not needed unless very long intervals)\n    // delta is signed, so negative means reverse rotation\n\n    float revolutions = (float)delta / ENCODER_CPR;\n    rps = revolutions / (SAMPLE_PERIOD/1000);\n}\n\n\nWhich is different from any approach I have seen my peers pursue in the lab. Bing claims that this makes use on built in hardware encoder handling that is more efficient than counting interrupts.\nAll I had to do was make minor edits and write a simple main function to begin testing this code. While this approach may have been viable, I could not get it to work and Bing was not helpful in debugging.\nOveralll, my impression is that this tool is great for ideating general approaches, but the implementation of those approaches are better left to the engineer, since it is incredibly difficult to debug another “person’s” code that you had no part in writing.\nI see myself using AI in the future only to give me ideas on how to go about solving a problem, not to try and solve the problem for me."
  },
  {
    "objectID": "labs/lab5/lab5.html#lab-5-interrupts",
    "href": "labs/lab5/lab5.html#lab-5-interrupts",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design of interrupt based firmware to calculate the angular velocity of a DC motor using quadrature encoders\n\n\n\nTo ensure maximum accuracy accross all speeds, we use rising and falling edge interrupts for both quad encoders, and then use the values values of the two quad encoder signals to determine the direction of rotation\n\n\n\nTo find the rotation speed of the motor, I have a variable that stores the number of IRQs that have occured which is incremented in the interrupt handlers for the A and B quad encoder signals. To turn this count into a speed, I have a while loop in my main function that resets the counter and an internal timer, waits for the timer to surpass 1 sample period (200 ms), then does the following calculation to find the number of revolutions per second\n\\[\nM (Pulses) = \\frac{N (Interrupts)}{4 (Interrupts/Pulse)}\n\\]\n\\[\nRPS = \\frac{\\frac{M (Pulses)}{408 (Pulses/Rev)}}{\\frac{P (ms)}{1000 (ms/s)}}\n\\]\nWhere N is the number of interrupts counted, M is the number of pulses, and P is the sample period in milliseconds.\nThis methodology was implemented into a program with the following process flow diagram. \n\n\n\nTo verify the timing calculations above, I used an oscilliscope to measure the period of a quad encoder pulse, and the used the known value of 408 pulses/rev to find the true RPS.\n \n\\[\nRPS = \\frac{F (pulse/s)}{408 (pulse/rev)} = \\frac{462 (pulse/s)}{408 (pulse/rev)} = 1.1326 rev/s\n\\]\nWhile this trace was taken, the output terminal reported an RPS of ~1.15, which is approximately equal to the true value calculated above.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 4: Schematic of motor and quad encoder circuit\n\n\nThe schematic in figure 4 demonstrates the simple wiring for the quad encoder to the motherboard.\n\n\n\n\nThe design accurately displayed the angular speed of the motor and direction of rotation across a wide range of speeds.\nThis lab took roughly 10 hours.\n\n\nTo investigate the advantage of interrupt based timing calculations to polling, I repeated this assignment to use polling instead of interrupts, and in the main while loop toggled a pin to probe the frequency of this sampling.\n\n\n\nFigure 5: Oscilliscope trace of main polling loop\n\n\nSince this pin toggles every time the main while loop cycles, one half period is the sample period for this polling based design. To ensure that polling does not miss any pin transition events, this sample frequency must be at least twice that of the quad encoders (per Shannons Theorem).\nThis means that the maximum pulses per second is 2 times the polling frequency, or 11.62 kHz. Finally, since there are 408 pulses per revolution, the maximum revolutions per second is\n\\[\nRPS \\le \\frac{11620 (pulses/s)}{408 (pulses/rev)} = 28.48 (rev/s)\n\\]\nSo polling should be adequate for the operating range of the motor.\n\n\n\n\nI gave MS Bing the following prompt:\n“Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?”\nAnd it produced the following code:\n\n// --- Initialization ---\nvoid Encoder_Init(void) {\n    // Enable GPIOA and TIM2 clocks\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n\n    // Configure PA0, PA1 as AF1 (TIM2_CH1, TIM2_CH2)\n    GPIOA-&gt;MODER &= ~((3 &lt;&lt; (0*2)) | (3 &lt;&lt; (1*2))); // clear mode\n    GPIOA-&gt;MODER |=  (2 &lt;&lt; (0*2)) | (2 &lt;&lt; (1*2));   // AF mode\n    GPIOA-&gt;AFR[0] |= (1 &lt;&lt; (0*4)) | (1 &lt;&lt; (1*4));   // AF1\n\n    // Configure TIM2 in encoder mode\n    TIM2-&gt;SMCR = TIM_SMCR_SMS_0 | TIM_SMCR_SMS_1;   // Encoder mode 3 (count on both TI1 and TI2)\n    TIM2-&gt;CCMR1 = (1 &lt;&lt; 0) | (1 &lt;&lt; 8);              // CC1S=01, CC2S=01 (inputs)\n    TIM2-&gt;CCER = 0;                                 // Rising edge polarity\n    TIM2-&gt;ARR = 0xFFFFFFFF;                         // Max count\n    TIM2-&gt;CNT = 0;                                  // Reset counter\n\n    // Enable update interrupt\n    TIM2-&gt;DIER |= TIM_DIER_UIE;\n    NVIC_EnableIRQ(TIM2_IRQn);\n\n    // Start timer\n    TIM2-&gt;CR1 |= TIM_CR1_CEN;\n}\n\n// --- Interrupt Handler ---\nvoid TIM2_IRQHandler(void) {\n    if (TIM2-&gt;SR & TIM_SR_UIF) {   // Update interrupt flag\n        TIM2-&gt;SR &= ~TIM_SR_UIF;   // Clear flag\n        // Handle overflow/underflow here\n    }\n}\n\n#define ENCODER_CPR   (PPR * 4)    // Example: 1024 PPR encoder, x4 decoding\n\nvolatile int32_t last_count = 0;\nvolatile float rps = 0.0f;\n\nvoid SysTick_Handler(void) {\n    int32_t current = TIM2-&gt;CNT;\n    int32_t delta = current - last_count;\n    last_count = current;\n\n    // Handle wraparound (TIM2 is 32-bit, so usually not needed unless very long intervals)\n    // delta is signed, so negative means reverse rotation\n\n    float revolutions = (float)delta / ENCODER_CPR;\n    rps = revolutions / (SAMPLE_PERIOD/1000);\n}\n\n\nWhich is different from any approach I have seen my peers pursue in the lab. Bing claims that this makes use on built in hardware encoder handling that is more efficient than counting interrupts.\nAll I had to do was make minor edits and write a simple main function to begin testing this code. While this approach may have been viable, I could not get it to work and Bing was not helpful in debugging.\nOveralll, my impression is that this tool is great for ideating general approaches, but the implementation of those approaches are better left to the engineer, since it is incredibly difficult to debug another “person’s” code that you had no part in writing.\nI see myself using AI in the future only to give me ideas on how to go about solving a problem, not to try and solve the problem for me."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification process for a 4x4 keypad matrix with TDM 7-segment display outputs\n\n\n\nTo make block level verification as simple as possible, I factored the design into three FSMs that each handle a small set of tasks, with handshakes between them where necessary.\nI did block formal verification for this project using SymbiYosys. With this tool, I proved that a set of design assertions were impossible to break for each major design element. For system level verification, I produces a simple simulation testbench to demonstrate the glue logic between the formally verified blocks.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure with the three major FSMs, an encoder to convert row and column indecis into a hex value, and the time division multiplexer circuit derived from lab 2\n\n\n\n\n\n\nfigure 2: controller FSM State Transition Diagram\n\n\n\n\n\nfigure 3: controller FSM State Transition Table\n\n\n\n\n\nfigure 4: row driver FSM State Transition Diagram\n\n\n\n\n\nfigure 5: row driver FSM State Transition Table\n\n\n\n\n\nfigure 6: debouncing FSM State Transition Diagram\n\n\n\n\n\nfigure 7: debouncing FSM State Transition Table\n\n\nFigures 2-7 demonstrate the design of the three FSMs seen in the block diagram in figure 1\n\n\n\n\n\n\nFigure 8: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 8 demonstrates the phsyical hardware layout of the design, with the 4x4 keypad, 7-segment display, PNP transistors, pull down resistors, and current limiting resistors.\n\n\n\nFor this lab we had 3 different resistor values to calculate.\nFirst, we needed the current limiting resistors for the 7-segment LED arrays driven by the PNP resistors. For safety, I aimed for ~3 mA. Red LEDs have a voltage drop of ~1.8V and there is a voltage drop of ~0.2V between the collector and emitter of the PNP transister, per the datasheet, so we get the following calculation\n\\[\nR = \\frac{3.3V - 0.2V - 1.8V}{3mA} = 433 \\Omega\n\\]\nNext, we have the resistor binding the base of the PNP transistor to the IO pin that powers each 7-segment display. Since the upper voltage is 3.3V going into a silicon diode that connects to the base, the voltage at the base is 0.7V lower or 2.6V. When the pin that is bridged to this terminal by a resistor is low, we wish to limit the current into the pin, so we aim for a large resistor. If we aim for around 3 mA of current, then we get the following equation for R:\n\\[\nR = \\frac{3.3V - 0.7V}{3mA} = 866 \\Omega\n\\]\nTo be extra safe and make use of readily available components, I used 680 Ohms for the current limiting resistors and 1 kOhms for the resistors connected to the PNPs.\nFinally, for the external pull down resistors I chose 680 Ohms since this value would safely be low enough to prevent bringing the default pin voltage above the lower logic level. This likely could have been increased to save power, but since that wasn’t a particular concern, I chose this lower value to be safe.\n\n\n\n\n\n\n\n\n\nfigure 9: Controller FSM Formal Verification Results\n\n\n\n\n\nfigure 10: Row Driver FSM Formal Verification Results\n\n\n\n\n\nfigure 11: Debouncer FSM Formal Verification Results\n\n\n\n\n\nfigure 12: Keypad Encoder Formal Verification Results\n\n\nThese formal verification results demonstrate that each major submodule adheres to a set of application specific design properties for all time, proving that they work as expected.\n\n\n\nfigure 13: Top Module Simulation Waveforms\n\n\n\n\n\nfigure 14: Top Module Simulation Output\n\n\n\n\n\nEvery button was checker for proper behavior. When one button was pressed, no other buttons affected the display. Additionally, I observed that the two segments did no flicker or bleed into one another, and were reletively bright.\n\n\n\n\nI was able to design a matrix keypad driver circuit to read button presses from a real-world user. I brushed up on my synchronous design skills and my ability to formally describe the intended behavior of a sequential design without explicit test cases, as to be able to use formal verification.\nI spent around 35 hours on this lab making sure my design meets all requirements\n\n\n\nFirst, I gave Microsoft Copilot the following prompt:\n“Target device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\nA clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.”\nInitially, it did not synthesize due to the use of a $clog2 function call for a cute one-liner priority encoder. After pointing this out, it make a custom SystemVerilog function to perform this functionality. After this change, it synthesized with the following netlist viewer result:\n\n\n\nfigure 15: First AI Prototype\n\n\nNext, I gave this LLM the following three prompts back-to-back:\n“Target device: Lattice iCE40 UP5K FPGA.\nOverall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\nCurrent Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\nWhen a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.”\n“Target device: Lattice iCE40 UP5K FPGA.\nWrite a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\nIterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.”\n“Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\nWrite a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\nUpdate the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.”\nAgain, it did not synthesize initially since it was missing a keypad encoder module. Once this was pointed out and corrected, I got the following:\n\n\n\nfigure 16: Second AI Prototype\n\n\nThese designs are prett similar to mine, but were done in a small fraction of the time. I would be curious to see how well they did on the physical hardware, as there are many subtle hardware edge cases that I am not sure the AI model is considering in producing this code.\nOverall I am impressed with its performance, but I am also not shocked it missed synthesis issues and came up with nonstandard solutions."
  },
  {
    "objectID": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "href": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification process for a 4x4 keypad matrix with TDM 7-segment display outputs\n\n\n\nTo make block level verification as simple as possible, I factored the design into three FSMs that each handle a small set of tasks, with handshakes between them where necessary.\nI did block formal verification for this project using SymbiYosys. With this tool, I proved that a set of design assertions were impossible to break for each major design element. For system level verification, I produces a simple simulation testbench to demonstrate the glue logic between the formally verified blocks.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure with the three major FSMs, an encoder to convert row and column indecis into a hex value, and the time division multiplexer circuit derived from lab 2\n\n\n\n\n\n\nfigure 2: controller FSM State Transition Diagram\n\n\n\n\n\nfigure 3: controller FSM State Transition Table\n\n\n\n\n\nfigure 4: row driver FSM State Transition Diagram\n\n\n\n\n\nfigure 5: row driver FSM State Transition Table\n\n\n\n\n\nfigure 6: debouncing FSM State Transition Diagram\n\n\n\n\n\nfigure 7: debouncing FSM State Transition Table\n\n\nFigures 2-7 demonstrate the design of the three FSMs seen in the block diagram in figure 1\n\n\n\n\n\n\nFigure 8: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 8 demonstrates the phsyical hardware layout of the design, with the 4x4 keypad, 7-segment display, PNP transistors, pull down resistors, and current limiting resistors.\n\n\n\nFor this lab we had 3 different resistor values to calculate.\nFirst, we needed the current limiting resistors for the 7-segment LED arrays driven by the PNP resistors. For safety, I aimed for ~3 mA. Red LEDs have a voltage drop of ~1.8V and there is a voltage drop of ~0.2V between the collector and emitter of the PNP transister, per the datasheet, so we get the following calculation\n\\[\nR = \\frac{3.3V - 0.2V - 1.8V}{3mA} = 433 \\Omega\n\\]\nNext, we have the resistor binding the base of the PNP transistor to the IO pin that powers each 7-segment display. Since the upper voltage is 3.3V going into a silicon diode that connects to the base, the voltage at the base is 0.7V lower or 2.6V. When the pin that is bridged to this terminal by a resistor is low, we wish to limit the current into the pin, so we aim for a large resistor. If we aim for around 3 mA of current, then we get the following equation for R:\n\\[\nR = \\frac{3.3V - 0.7V}{3mA} = 866 \\Omega\n\\]\nTo be extra safe and make use of readily available components, I used 680 Ohms for the current limiting resistors and 1 kOhms for the resistors connected to the PNPs.\nFinally, for the external pull down resistors I chose 680 Ohms since this value would safely be low enough to prevent bringing the default pin voltage above the lower logic level. This likely could have been increased to save power, but since that wasn’t a particular concern, I chose this lower value to be safe.\n\n\n\n\n\n\n\n\n\nfigure 9: Controller FSM Formal Verification Results\n\n\n\n\n\nfigure 10: Row Driver FSM Formal Verification Results\n\n\n\n\n\nfigure 11: Debouncer FSM Formal Verification Results\n\n\n\n\n\nfigure 12: Keypad Encoder Formal Verification Results\n\n\nThese formal verification results demonstrate that each major submodule adheres to a set of application specific design properties for all time, proving that they work as expected.\n\n\n\nfigure 13: Top Module Simulation Waveforms\n\n\n\n\n\nfigure 14: Top Module Simulation Output\n\n\n\n\n\nEvery button was checker for proper behavior. When one button was pressed, no other buttons affected the display. Additionally, I observed that the two segments did no flicker or bleed into one another, and were reletively bright.\n\n\n\n\nI was able to design a matrix keypad driver circuit to read button presses from a real-world user. I brushed up on my synchronous design skills and my ability to formally describe the intended behavior of a sequential design without explicit test cases, as to be able to use formal verification.\nI spent around 35 hours on this lab making sure my design meets all requirements\n\n\n\nFirst, I gave Microsoft Copilot the following prompt:\n“Target device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\nA clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.”\nInitially, it did not synthesize due to the use of a $clog2 function call for a cute one-liner priority encoder. After pointing this out, it make a custom SystemVerilog function to perform this functionality. After this change, it synthesized with the following netlist viewer result:\n\n\n\nfigure 15: First AI Prototype\n\n\nNext, I gave this LLM the following three prompts back-to-back:\n“Target device: Lattice iCE40 UP5K FPGA.\nOverall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\nCurrent Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\nWhen a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.”\n“Target device: Lattice iCE40 UP5K FPGA.\nWrite a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\nIterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.”\n“Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\nWrite a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\nUpdate the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.”\nAgain, it did not synthesize initially since it was missing a keypad encoder module. Once this was pointed out and corrected, I got the following:\n\n\n\nfigure 16: Second AI Prototype\n\n\nThese designs are prett similar to mine, but were done in a small fraction of the time. I would be curious to see how well they did on the physical hardware, as there are many subtle hardware edge cases that I am not sure the AI model is considering in producing this code.\nOverall I am impressed with its performance, but I am also not shocked it missed synthesis issues and came up with nonstandard solutions."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification of a simple FPGA design to become familiar with the E155 toolflow. The design contains a seven segment display decoder, a simple digital oscillator, and a few logic gates.\n\n\n\nThe core part of the design is a 4 to 7 bit decoder for controlling a 7 segment display to display the hex value of a 4 bit input signal. This was created using behavioral SystemVerilog code and was verfified with a simple testbench, where the input signal was incremented from 0000 to 1111 and values for each bit of the decoded output was checked against the expected stream of bits. In hindsight, this was likely a convoluted approach to verification, but since the module is just a truth table, using standard test vectors would essentially mean copying the RTL code to see if it matched itself.\nFor the top level module, the seven segment decoder was instantiated alongside a high speed oscillator (HSOSC) to generate a 48 MHz clock. This clock was fed into a digital clock divider where a constant P is added to a 32 bit register on each rising edge of the fast clock, causing the most significant bit to toggle with a frequency given by the following equation:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 32 bits, F = 48 MHz, and f = 2.4 Hz, we can solve for P = 215 to achieve the desired frequency.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the 7:4 decoder, two logic gates, high frequency clock, and clock divider\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the seven LEDs of the seven segment display with current limiting resistors, the three on-board LEDs driven by the design, and the input DIP switches.\n\n\n\nFrom the data sheet the LED display has a voltage drop of roughly 2 volts. Since we are using a 3.3 Volt supply and the FPGA pins have an 8 mA current limit, we can set up the following equation for the minimum current limiting resistor value:\n\\[\nR = \\frac{3.3V - 2V}{8mA} = 165 \\Omega\n\\]\nHowever, to be extra careful not to burn out my LED display, I used a factor of safety of 2 and used 330 Ohm resistors.\n\n\n\n\n\n\n\n\n\nFigure 3: Testbench simulation waveforms from decoder module\n\n\n\n\n\nFigure 4: Successful testbench output from seven segment decoder simulation\n\n\n\n\n\nFigure 5: Testbench Simulation of top level module\n\n\n\n\n\nFigure 6: Successful testbench output from top level simulation\n\n\nThe design was shown to meet all specifications in simulation, except the blinking LED which was tested in hardware.\n\n\n\nThe seven segment display and two gate-driven LEDs responded to input DIP switches in accordance with the design spec\n\n\n\nFigure 7: Photograph of oscilliscope measuring ~2.4Hz LED blinking\n\n\nFigure 7 shows the corrent timing of the blinking LED in hardware.\n\n\n\n\nI was able to set up the E155 toolchain and demonstrate it on this moderately simple lab. I look forward to building experience with this flow on future labs. I spent roughly 15 hours on this lab.\n\n\n\nI gave Microsoft Bing the following prompt to see if it could replicate some of my work:\n“Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nInitally, it gave me the following code:\nmodule led_blinker_2hz (\n    output logic led\n);\n\n    // Internal oscillator output\n    logic clk;\n    logic clk_en;\n\n    // Instantiate the high-frequency oscillator (typically 48 MHz)\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\")  // No division: 48 MHz\n    ) hf_osc_inst (\n        .CLKHFEN(clk_en),\n        .CLKHFPU(clk_en),\n        .CLKHF(clk)\n    );\n\n    // Enable the oscillator\n    initial clk_en = 1'b1;\n\n    // Counter to divide 48 MHz down to 2 Hz\n    // 48,000,000 / 2 = 24,000,000 clock cycles per toggle\n    localparam int COUNT_MAX = 24_000_000;\n    logic [$clog2(COUNT_MAX)-1:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        if (counter == COUNT_MAX - 1) begin\n            counter &lt;= 0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\nThis did not synthesize since it used a different clock generator module, SB_HFOSC. When I asked it to correct the error, it insisted that it was related to a missing package. However, once I changed this module to HSOSC, it synthesized just fine.\nThis prototype made me question the landscape of digital design. It seems that these models have gotten very good at the big picture, and only now struggle with the software specific details."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification of a simple FPGA design to become familiar with the E155 toolflow. The design contains a seven segment display decoder, a simple digital oscillator, and a few logic gates.\n\n\n\nThe core part of the design is a 4 to 7 bit decoder for controlling a 7 segment display to display the hex value of a 4 bit input signal. This was created using behavioral SystemVerilog code and was verfified with a simple testbench, where the input signal was incremented from 0000 to 1111 and values for each bit of the decoded output was checked against the expected stream of bits. In hindsight, this was likely a convoluted approach to verification, but since the module is just a truth table, using standard test vectors would essentially mean copying the RTL code to see if it matched itself.\nFor the top level module, the seven segment decoder was instantiated alongside a high speed oscillator (HSOSC) to generate a 48 MHz clock. This clock was fed into a digital clock divider where a constant P is added to a 32 bit register on each rising edge of the fast clock, causing the most significant bit to toggle with a frequency given by the following equation:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 32 bits, F = 48 MHz, and f = 2.4 Hz, we can solve for P = 215 to achieve the desired frequency.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the 7:4 decoder, two logic gates, high frequency clock, and clock divider\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the seven LEDs of the seven segment display with current limiting resistors, the three on-board LEDs driven by the design, and the input DIP switches.\n\n\n\nFrom the data sheet the LED display has a voltage drop of roughly 2 volts. Since we are using a 3.3 Volt supply and the FPGA pins have an 8 mA current limit, we can set up the following equation for the minimum current limiting resistor value:\n\\[\nR = \\frac{3.3V - 2V}{8mA} = 165 \\Omega\n\\]\nHowever, to be extra careful not to burn out my LED display, I used a factor of safety of 2 and used 330 Ohm resistors.\n\n\n\n\n\n\n\n\n\nFigure 3: Testbench simulation waveforms from decoder module\n\n\n\n\n\nFigure 4: Successful testbench output from seven segment decoder simulation\n\n\n\n\n\nFigure 5: Testbench Simulation of top level module\n\n\n\n\n\nFigure 6: Successful testbench output from top level simulation\n\n\nThe design was shown to meet all specifications in simulation, except the blinking LED which was tested in hardware.\n\n\n\nThe seven segment display and two gate-driven LEDs responded to input DIP switches in accordance with the design spec\n\n\n\nFigure 7: Photograph of oscilliscope measuring ~2.4Hz LED blinking\n\n\nFigure 7 shows the corrent timing of the blinking LED in hardware.\n\n\n\n\nI was able to set up the E155 toolchain and demonstrate it on this moderately simple lab. I look forward to building experience with this flow on future labs. I spent roughly 15 hours on this lab.\n\n\n\nI gave Microsoft Bing the following prompt to see if it could replicate some of my work:\n“Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nInitally, it gave me the following code:\nmodule led_blinker_2hz (\n    output logic led\n);\n\n    // Internal oscillator output\n    logic clk;\n    logic clk_en;\n\n    // Instantiate the high-frequency oscillator (typically 48 MHz)\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\")  // No division: 48 MHz\n    ) hf_osc_inst (\n        .CLKHFEN(clk_en),\n        .CLKHFPU(clk_en),\n        .CLKHF(clk)\n    );\n\n    // Enable the oscillator\n    initial clk_en = 1'b1;\n\n    // Counter to divide 48 MHz down to 2 Hz\n    // 48,000,000 / 2 = 24,000,000 clock cycles per toggle\n    localparam int COUNT_MAX = 24_000_000;\n    logic [$clog2(COUNT_MAX)-1:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        if (counter == COUNT_MAX - 1) begin\n            counter &lt;= 0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\nThis did not synthesize since it used a different clock generator module, SB_HFOSC. When I asked it to correct the error, it insisted that it was related to a missing package. However, once I changed this module to HSOSC, it synthesized just fine.\nThis prototype made me question the landscape of digital design. It seems that these models have gotten very good at the big picture, and only now struggle with the software specific details."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Getting Started\n\n\nFirst Steps into E155\n\n\n\n\n\nAug 29, 2025\n\n\nCorey Hickson\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Corey Hickson is a class of 2026 Engineering Major at Harvey Mudd College with background in design verification and digital design. As a VLSI research fellow with the Clay-Wolkin Fellowship at Harvey Mudd, he has conducted core level functional testing and coverage collection of a RISC-V processor core. While interning at Skyworks Solutions in the summer of 2025, he conducted whole core level formal verification of a different RISC-V processor core. Corey looks forward to the 2025-26 HRL Laboratories engineering clinic project, where he and his team will work towards producing a C program to emulate a mixed analog-digital quantum qubit control board. After graduation, he will return to Skyworks as a Design Verification Engineer 1 to continue his work in formal verification from the past summer."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification process for a time division multiplexed 7-segment display pair.\n\n\n\nThe design uses a single time-multiplexed 7 segment decoder that switches between two sets of hex nibble inputs at 60 Hz. This is done by dividing a 48 MHz clock to 120 Hz, and using this slow clock to drive a toggle flop to divide down to 60 Hz (called the select line). The select line switches between the two inputs and two power pins and the slow clock triggers flops on the output to ensure clean transitions between the two displays\nI did formal verification for this project using SymbiYosys. For this, when synthesizing for formal verification there is an external clock input that takes the place of the slow clock. I proved that a set of design assertions cannot be broken for 30 cycles, and that there is no trace through the design that breaks an assertion on the 1000th cycle, so by interpolating we can declare the design bug free with respect to these assertions.\nFor the slow clock generation, I used the same formula as last week with a different target frequency:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 24 bits, F = 48 MHz, and f = 120 Hz, we can solve for P = 42 to achieve the desired frequency.\nSince this was not covered in formal verification, this portion of the design was verified with a simple testbench simulation.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the single 7:4 decoder, high frequency clock, clock divider, and a few registers and gates\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the two 7-segment displays, 5 additional LEDs, 4 external DIP switches, and 2 PNP transistors.\n\n\n\nFor this lab we had 3 different resistor values to calculate.\nFirst, we needed the current limiting resistors for the single LEDs driven by IO pins on the FPGA. From the FPGA datasheet, the FPGA can ouput 3.3V on an IO pin at a maximum of 8 mA of current. For safety, I aimed for ~3 mA. Red LEDs have a voltage drop of ~1.8V, so we get the following equation:\n\\[\nR = \\frac{3.3V - 1.8V}{3mA} = 500 \\Omega\n\\]\nNext, we have the current limiting resistors for the 7-segment LED arrays. These follow the same general format as the previous calculation, but since there is a voltage drop of ~0.2V between the collector and emitter of the PNP transister, per the datasheet, the calculation becomes the following:\n\\[\nR = \\frac{3.3V - 0.2V - 1.8V}{3mA} = 433 \\Omega\n\\]\nFinally, we have the resistor binding the base of the PNP transistor to the IO pin that powers each 7-segment display. Since the upper voltage is 3.3V going into a silicon diode that connects to the base, the voltage at the base is 0.7V lower or 2.6V. When the pin that is bridged to this terminal by a resistor is low, we wish to limit the current into the pin, so we aim for a large resistor. If we aim for around 3 mA of current, then we get the following equation for R:\n\\[\nR = \\frac{3.3V - 0.7V - 0}{3mA} = 866 \\Omega\n\\]\nTo be extra safe and make use of readily available components, I used 680 Ohms for the current limiting resistors and 1 kOhms for the resistors connected to the PNPs.\n\n\n\n\n\n\n\n\n\nFigure 3: Bounded formal proof results (depth of 30 cycles)\n\n\n\n\n\nFigure 4: Deep formal bug hunt results (checking all ways to reach cycle 1000)\n\n\n\n\n\nFigure 5: Simulation waveforms for clock verification\n\n\n\n\n\nFigure 6: Simulation output for clock verification\n\n\nFormal verification proved that the design met all cycle dependant specifications (based on assumptions about the clock signal), and the simple simulation demonstrated expected behavior of the clock.\n\n\n\nThe input space was sampled at random to check a subset of the design functionality. Additionally, I observed that the two segments did no flicker or bleed into one another, and were reletively bright.\n\n\n\n\nI was able to design a time division multiplexing circuit to have two design elements share a single piece of expensive harware. I brushed up on my synchronous design skills and my ability to formally describe the intended behavior of a sequential design without explicit test cases, as to be able to use formal verification.\nI spent around 15 hours on this lab\n\n\n\nI gave google’s “AI Mode” search engine the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”\nAnd it produced the commented out code in the AI section of the lab repository here. This design has the following structure:\n\n\n\nFigure 7: First AI design netlist viewer\n\n\nThis initially had a minor bug where the dimensions of a logic vector were given after the name. Once this was corrected, the design synthesized without issue.\nNext, I gave a new AI session my files from lab 1 and the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.”\nThis time, there were no issues synthesizing and it produced the following design:\n\n\n\nFigure 7: Second AI design netlist viewer\n\n\nThis is similar to my design for this lab, but without the registers on the output side.\nThis activity led me to question the necessity of the registers I added at the output, as the LLM did not feel the need to add them in its version of the design, which otherwiss lines up with mine. I am again impressed by the ability of LLMs to carry out digital design. I am beginning to wonder if they will come after my Design Verification career…"
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification process for a time division multiplexed 7-segment display pair.\n\n\n\nThe design uses a single time-multiplexed 7 segment decoder that switches between two sets of hex nibble inputs at 60 Hz. This is done by dividing a 48 MHz clock to 120 Hz, and using this slow clock to drive a toggle flop to divide down to 60 Hz (called the select line). The select line switches between the two inputs and two power pins and the slow clock triggers flops on the output to ensure clean transitions between the two displays\nI did formal verification for this project using SymbiYosys. For this, when synthesizing for formal verification there is an external clock input that takes the place of the slow clock. I proved that a set of design assertions cannot be broken for 30 cycles, and that there is no trace through the design that breaks an assertion on the 1000th cycle, so by interpolating we can declare the design bug free with respect to these assertions.\nFor the slow clock generation, I used the same formula as last week with a different target frequency:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 24 bits, F = 48 MHz, and f = 120 Hz, we can solve for P = 42 to achieve the desired frequency.\nSince this was not covered in formal verification, this portion of the design was verified with a simple testbench simulation.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the single 7:4 decoder, high frequency clock, clock divider, and a few registers and gates\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the two 7-segment displays, 5 additional LEDs, 4 external DIP switches, and 2 PNP transistors.\n\n\n\nFor this lab we had 3 different resistor values to calculate.\nFirst, we needed the current limiting resistors for the single LEDs driven by IO pins on the FPGA. From the FPGA datasheet, the FPGA can ouput 3.3V on an IO pin at a maximum of 8 mA of current. For safety, I aimed for ~3 mA. Red LEDs have a voltage drop of ~1.8V, so we get the following equation:\n\\[\nR = \\frac{3.3V - 1.8V}{3mA} = 500 \\Omega\n\\]\nNext, we have the current limiting resistors for the 7-segment LED arrays. These follow the same general format as the previous calculation, but since there is a voltage drop of ~0.2V between the collector and emitter of the PNP transister, per the datasheet, the calculation becomes the following:\n\\[\nR = \\frac{3.3V - 0.2V - 1.8V}{3mA} = 433 \\Omega\n\\]\nFinally, we have the resistor binding the base of the PNP transistor to the IO pin that powers each 7-segment display. Since the upper voltage is 3.3V going into a silicon diode that connects to the base, the voltage at the base is 0.7V lower or 2.6V. When the pin that is bridged to this terminal by a resistor is low, we wish to limit the current into the pin, so we aim for a large resistor. If we aim for around 3 mA of current, then we get the following equation for R:\n\\[\nR = \\frac{3.3V - 0.7V - 0}{3mA} = 866 \\Omega\n\\]\nTo be extra safe and make use of readily available components, I used 680 Ohms for the current limiting resistors and 1 kOhms for the resistors connected to the PNPs.\n\n\n\n\n\n\n\n\n\nFigure 3: Bounded formal proof results (depth of 30 cycles)\n\n\n\n\n\nFigure 4: Deep formal bug hunt results (checking all ways to reach cycle 1000)\n\n\n\n\n\nFigure 5: Simulation waveforms for clock verification\n\n\n\n\n\nFigure 6: Simulation output for clock verification\n\n\nFormal verification proved that the design met all cycle dependant specifications (based on assumptions about the clock signal), and the simple simulation demonstrated expected behavior of the clock.\n\n\n\nThe input space was sampled at random to check a subset of the design functionality. Additionally, I observed that the two segments did no flicker or bleed into one another, and were reletively bright.\n\n\n\n\nI was able to design a time division multiplexing circuit to have two design elements share a single piece of expensive harware. I brushed up on my synchronous design skills and my ability to formally describe the intended behavior of a sequential design without explicit test cases, as to be able to use formal verification.\nI spent around 15 hours on this lab\n\n\n\nI gave google’s “AI Mode” search engine the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”\nAnd it produced the commented out code in the AI section of the lab repository here. This design has the following structure:\n\n\n\nFigure 7: First AI design netlist viewer\n\n\nThis initially had a minor bug where the dimensions of a logic vector were given after the name. Once this was corrected, the design synthesized without issue.\nNext, I gave a new AI session my files from lab 1 and the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.”\nThis time, there were no issues synthesizing and it produced the following design:\n\n\n\nFigure 7: Second AI design netlist viewer\n\n\nThis is similar to my design for this lab, but without the registers on the output side.\nThis activity led me to question the necessity of the registers I added at the output, as the LLM did not feel the need to add them in its version of the design, which otherwiss lines up with mine. I am again impressed by the ability of LLMs to carry out digital design. I am beginning to wonder if they will come after my Design Verification career…"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design of a device driver library to play music using a microcontroller\n\n\n\nThe primary challenge of this lab was the close reading of the spec required to configure the registers to work together properly to wait accurate amounts of time and output accurate pitchs via a PWM output\n\n\n\nFor my delay timer which simply waited an input number of milliseconds, I chose PSC = 800 and ARR = 100 such that the timer waits exactly 1 ms between reset and UIF going high. This means that delays are always in mulitples of 1 ms, with some very small overhead for resetting the counter. This means that the minimum wait time is 1 ms and the maximum is bounded by the size of the int iteration variable in a for loop (2^32 or ~4 billion milliseconds).\nFor creating the PWM square wave I began by chosing PSC = 1 and naively calculating ARR by dividing the clock frequency by the desired pitch frequency. Then, I check if the ARR takes up more than 16 bits, in which case I divide it by two and double the PSC to keep the effective frequency the same. In this way, the PWM frequency will be as close as possible to the desired frequency since it is accurate to within the limits of precision of the fast clock frequency.\nIn theory, this means that the lower limit on the pitch are the clock frequency.\nThe upper bound on the pitch is a bit trickier to calculate.\n\n\n\nFigure 1: Calculation of minimum pitch\n\n\nAdditionally, the percent error is going to be worst for higher frequencies since the resolution depends on the frequency of the fast clock. In the worst case, this is about 1kHz with a margin of error of the period of 80 MHz.\n\n\n\nFigure 2: Calculation of worst case frequency error\n\n\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\n\nFigure 3: Schematic of Physical Breadboard Circuit\n\n\nThe schematic from figure 3 is derived from the reference design in the data sheet for the audio amp found here\n\n\n\nFigure 4: Audio amp reference design\n\n\n\n\n\nI successfully produces a set of drivers to program peripherals on the MCU without use of the hardware abstraction layer. This lab took me roughly 12 hours.\n\n\n\nI gave MS BING the following prompt:\n“What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?”\nto which it responding the following:\nTo generate frequencies between 220Hz and 1kHz on the STM32L432KC, here’s a breakdown of the best timer choices, relevant formulas, and configuration steps:\n🕒 Recommended Timers for Frequency Output The STM32L432KC features several general-purpose timers: Timer Bit Width Channels GPIO Compatibility Notes TIM2 32-bit 4 Good Ideal for low-frequency precision TIM3 16-bit 4 Good Sufficient for 220Hz–1kHz range TIM21 16-bit 2 Limited Less flexible for GPIO TIM22 16-bit 2 Limited Similar to TIM21\nBest choice: TIM2 is ideal due to its 32-bit resolution and wide GPIO mapping options.\n📐 Key Formula for Timer Frequency To generate a specific output frequency ( f_{out} ), use: [ f_{out} = ] Where: ( f_{timer} ) is the timer input clock (e.g., 16MHz from APB1) PSC = Prescaler ARR = Auto-reload register You can adjust PSC and ARR to achieve your target frequency. For example, to get 440Hz from a 16MHz clock: [ (PSC + 1) (ARR + 1) = ,364 ] Choose PSC = 35, ARR = 1039 → ( f_{out} 440.1Hz ) Use NicheCalcs STM32 Timer Calculator to simplify this process.\n⚙️ Registers to Configure To set up a timer for output on a GPIO pin (e.g., PWM or toggle mode): Enable Timer Clock\nRCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\nConfigure GPIO Pin for Alternate Function\nRCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN; GPIOA-&gt;MODER |= (0x2 &lt;&lt; GPIO_MODER_MODER0_Pos); // AF mode GPIOA-&gt;AFR[0] |= (0x1 &lt;&lt; GPIO_AFRL_AFSEL0_Pos); // AF1 for TIM2_CH1\nSet Timer Mode and Output Compare\nTIM2-&gt;PSC = 35; TIM2-&gt;ARR = 1039; TIM2-&gt;CCR1 = ARR / 2; // 50% duty cycle TIM2-&gt;CCMR1 |= (0x6 &lt;&lt; TIM_CCMR1_OC1M_Pos); // PWM mode 1 TIM2-&gt;CCER |= TIM_CCER_CC1E; // Enable output TIM2-&gt;CR1 |= TIM_CR1_CEN; // Start timer\nOptional: Force ARR update\nTIM2-&gt;EGR |= TIM_EGR_UG;\nWould you like help calculating the exact PSC and ARR values for a full range of notes or frequencies? I can generate a table for you.\nTo me this looks promising, and maybe could have helped me get a better start on the lab. However, I do not see how this would’ve helped me to configue the frequency of the PWM signal for different tones.\nI attemped to provide the reference mandual to a subsequent BING chat, and it simply hung without responding anything."
  },
  {
    "objectID": "labs/lab4/lab4.html#lab-4-digital-audio",
    "href": "labs/lab4/lab4.html#lab-4-digital-audio",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design of a device driver library to play music using a microcontroller\n\n\n\nThe primary challenge of this lab was the close reading of the spec required to configure the registers to work together properly to wait accurate amounts of time and output accurate pitchs via a PWM output\n\n\n\nFor my delay timer which simply waited an input number of milliseconds, I chose PSC = 800 and ARR = 100 such that the timer waits exactly 1 ms between reset and UIF going high. This means that delays are always in mulitples of 1 ms, with some very small overhead for resetting the counter. This means that the minimum wait time is 1 ms and the maximum is bounded by the size of the int iteration variable in a for loop (2^32 or ~4 billion milliseconds).\nFor creating the PWM square wave I began by chosing PSC = 1 and naively calculating ARR by dividing the clock frequency by the desired pitch frequency. Then, I check if the ARR takes up more than 16 bits, in which case I divide it by two and double the PSC to keep the effective frequency the same. In this way, the PWM frequency will be as close as possible to the desired frequency since it is accurate to within the limits of precision of the fast clock frequency.\nIn theory, this means that the lower limit on the pitch are the clock frequency.\nThe upper bound on the pitch is a bit trickier to calculate.\n\n\n\nFigure 1: Calculation of minimum pitch\n\n\nAdditionally, the percent error is going to be worst for higher frequencies since the resolution depends on the frequency of the fast clock. In the worst case, this is about 1kHz with a margin of error of the period of 80 MHz.\n\n\n\nFigure 2: Calculation of worst case frequency error\n\n\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\n\nFigure 3: Schematic of Physical Breadboard Circuit\n\n\nThe schematic from figure 3 is derived from the reference design in the data sheet for the audio amp found here\n\n\n\nFigure 4: Audio amp reference design\n\n\n\n\n\nI successfully produces a set of drivers to program peripherals on the MCU without use of the hardware abstraction layer. This lab took me roughly 12 hours.\n\n\n\nI gave MS BING the following prompt:\n“What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?”\nto which it responding the following:\nTo generate frequencies between 220Hz and 1kHz on the STM32L432KC, here’s a breakdown of the best timer choices, relevant formulas, and configuration steps:\n🕒 Recommended Timers for Frequency Output The STM32L432KC features several general-purpose timers: Timer Bit Width Channels GPIO Compatibility Notes TIM2 32-bit 4 Good Ideal for low-frequency precision TIM3 16-bit 4 Good Sufficient for 220Hz–1kHz range TIM21 16-bit 2 Limited Less flexible for GPIO TIM22 16-bit 2 Limited Similar to TIM21\nBest choice: TIM2 is ideal due to its 32-bit resolution and wide GPIO mapping options.\n📐 Key Formula for Timer Frequency To generate a specific output frequency ( f_{out} ), use: [ f_{out} = ] Where: ( f_{timer} ) is the timer input clock (e.g., 16MHz from APB1) PSC = Prescaler ARR = Auto-reload register You can adjust PSC and ARR to achieve your target frequency. For example, to get 440Hz from a 16MHz clock: [ (PSC + 1) (ARR + 1) = ,364 ] Choose PSC = 35, ARR = 1039 → ( f_{out} 440.1Hz ) Use NicheCalcs STM32 Timer Calculator to simplify this process.\n⚙️ Registers to Configure To set up a timer for output on a GPIO pin (e.g., PWM or toggle mode): Enable Timer Clock\nRCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\nConfigure GPIO Pin for Alternate Function\nRCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN; GPIOA-&gt;MODER |= (0x2 &lt;&lt; GPIO_MODER_MODER0_Pos); // AF mode GPIOA-&gt;AFR[0] |= (0x1 &lt;&lt; GPIO_AFRL_AFSEL0_Pos); // AF1 for TIM2_CH1\nSet Timer Mode and Output Compare\nTIM2-&gt;PSC = 35; TIM2-&gt;ARR = 1039; TIM2-&gt;CCR1 = ARR / 2; // 50% duty cycle TIM2-&gt;CCMR1 |= (0x6 &lt;&lt; TIM_CCMR1_OC1M_Pos); // PWM mode 1 TIM2-&gt;CCER |= TIM_CCER_CC1E; // Enable output TIM2-&gt;CR1 |= TIM_CR1_CEN; // Start timer\nOptional: Force ARR update\nTIM2-&gt;EGR |= TIM_EGR_UG;\nWould you like help calculating the exact PSC and ARR values for a full range of notes or frequencies? I can generate a table for you.\nTo me this looks promising, and maybe could have helped me get a better start on the lab. However, I do not see how this would’ve helped me to configue the frequency of the PWM signal for different tones.\nI attemped to provide the reference mandual to a subsequent BING chat, and it simply hung without responding anything."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design of an Internet of Things based temperature sensor and webpage\n\n\n\nTo record temperatures to display on the device’s webpage, I used a SPI temperature sensor which is written to for configuration and read from to get the temperature in fixed point format. The DS1722 temperature sensor’s data sheet can be found here\nFor this, I had to write a custom SPI library in C to configure the SPI registers on the MCU and drive data out and read data back.\n\n\n\nI designed the webpage to have button inputs to configure the number of bits of resolution via an HTTP request in the same way that the starter code turns a LED on and off.\n\n\n\nFigure 1: temperature sensor webpage\n\n\n\n\n\nThe C source code for this lab can by found on my github page\n\n\n\n\n\nFigure 2: Schematic of SPI temperature sensor circuit\n\n\n\n\n\nTo verify SPI transactions occured properl, I used a logic analyzer to show an SPI read and write between the MCU and temperature sensor\n\n\n\nFigure 3: Logic analyzer trace demonstrating proper SPI behavior\n\n\n\n\n\n\nMy design successfully displayed the temperature data from a DS1722 temperature sensor on a webpage with button selected 8 to 12 bit resolution.\nThis lab took me 10 hours\n\n\n\nI fed google AI mode the two promps, but It refused to produce any HTML code, so I tried Microsoft Copilot and it produced the following code:\nHTML Webpage\nchar* AI_page = \"\\\n&lt;!DOCTYPE html&gt;\\\n&lt;html lang=\\\"en\\\"&gt;\\\n&lt;head&gt;\\\n &lt;meta charset=\\\"UTF-8\\\" /&gt;\\\n &lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"/&gt;\\\n &lt;title&gt;Temperature Sensor Dashboard&lt;/title&gt;\\\n &lt;style&gt;\\\n   body {\\\n     font-family: 'Segoe UI', sans-serif;\\\n     background: #f4f7f9;\\\n     color: #333;\\\n     margin: 0;\\\n     padding: 0;\\\n   }\\\n   header {\\\n     background: #0078d4;\\\n     color: white;\\\n     padding: 1rem;\\\n     text-align: center;\\\n   }\\\n   .container {\\\n     max-width: 600px;\\\n     margin: 2rem auto;\\\n     padding: 2rem;\\\n     background: white;\\\n     border-radius: 8px;\\\n     box-shadow: 0 2px 8px rgba(0,0,0,0.1);\\\n   }\\\n   .section {\\\n     margin-bottom: 2rem;\\\n   }\\\n   .section h2 {\\\n     margin-bottom: 1rem;\\\n     font-size: 1.2rem;\\\n     color: #0078d4;\\\n   }\\\n   .temperature-display {\\\n     font-size: 2.5rem;\\\n     font-weight: bold;\\\n     text-align: center;\\\n     margin: 1rem 0;\\\n   }\\\n   .controls {\\\n     display: flex;\\\n     justify-content: space-between;\\\n     align-items: center;\\\n   }\\\n   .controls label {\\\n     margin-right: 0.5rem;\\\n   }\\\n   .led-toggle {\\\n     display: flex;\\\n     align-items: center;\\\n   }\\\n   button {\\\n     padding: 0.5rem 1rem;\\\n     background: #0078d4;\\\n     color: white;\\\n     border: none;\\\n     border-radius: 4px;\\\n     cursor: pointer;\\\n   }\\\n   button:hover {\\\n     background: #005fa3;\\\n   }\\\n   select {\\\n     padding: 0.4rem;\\\n   }\\\n &lt;/style&gt;\\\n&lt;/head&gt;\\\n&lt;body&gt;\\\n &lt;header&gt;\\\n   &lt;h1&gt;Temperature Sensor Dashboard&lt;/h1&gt;\\\n &lt;/header&gt;\\\n &lt;div class=\\\"container\\\"&gt;\\\n   &lt;div class=\\\"section\\\"&gt;\\\n     &lt;h2&gt;Current Temperature&lt;/h2&gt;\\\n     &lt;div class=\\\"temperature-display\\\" id=\\\"tempValue\\\"&gt;-- °C&lt;/div&gt;\\\n   &lt;/div&gt;\\\n   &lt;div class=\\\"section controls\\\"&gt;\\\n     &lt;div class=\\\"led-toggle\\\"&gt;\\\n       &lt;label for=\\\"ledSwitch\\\"&gt;LED:&lt;/label&gt;\\\n       &lt;button id=\\\"ledSwitch\\\"&gt;Toggle&lt;/button&gt;\\\n     &lt;/div&gt;\\\n     &lt;div&gt;\\\n       &lt;label for=\\\"precisionSelect\\\"&gt;Precision:&lt;/label&gt;\\\n       &lt;select id=\\\"precisionSelect\\\"&gt;\\\n         &lt;option value=\\\"0\\\"&gt;0 decimal&lt;/option&gt;\\\n         &lt;option value=\\\"1\\\" selected&gt;1 decimal&lt;/option&gt;\\\n         &lt;option value=\\\"2\\\"&gt;2 decimals&lt;/option&gt;\\\n       &lt;/select&gt;\\\n     &lt;/div&gt;\\\n   &lt;/div&gt;\\\n &lt;/div&gt;\\\n &lt;script&gt;\\\n   let ledState = false;\\\n   let precision = 1;\\\n   function fetchTemperature() {\\\n     // Simulate fetching temperature from a sensor\\\n     const rawTemp = 22.3456 + Math.random(); // Simulated temperature\\\n     const temp = rawTemp.toFixed(precision);\\\n     document.getElementById('tempValue').textContent = `${temp} °C`;\\\n   }\\\n   document.getElementById('ledSwitch').addEventListener('click', () =&gt; {\\\n     ledState = !ledState;\\\n     // Replace with actual API call to toggle LED\\\n     alert(`LED turned ${ledState ? 'ON' : 'OFF'}`);\\\n   });\\\n   document.getElementById('precisionSelect').addEventListener('change', (e) =&gt; {\\\n     precision = parseInt(e.target.value);\\\n     fetchTemperature();\\\n   });\\\n   // Initial fetch and update every 5 seconds\\\n   fetchTemperature();\\\n   setInterval(fetchTemperature, 5000);\\\n &lt;/script&gt;\\\n&lt;/body&gt;\\\n&lt;/html&gt;\";\n\n\n\nFigure 4: AI created webpage\n\n\nSPI code\n#include \"stm32l4xx.h\"  // CMSIS header for STM32L432KC\n\n#define DS1722_CS_PORT GPIOA\n#define DS1722_CS_PIN  GPIO_PIN_4\n\n#define DS1722_READ_TEMP_CMD 0x01  // Read temperature command\n\n// Helper macros to control CS pin\n#define DS1722_CS_LOW()  (DS1722_CS_PORT-&gt;BSRR = (uint32_t)DS1722_CS_PIN &lt;&lt; 16)\n#define DS1722_CS_HIGH() (DS1722_CS_PORT-&gt;BSRR = DS1722_CS_PIN)\n\nfloat DS1722_ReadTemperature(SPI_TypeDef *SPIx) {\n    uint8_t tx_buf[3] = { DS1722_READ_TEMP_CMD, 0x00, 0x00 };\n    uint8_t rx_buf[3] = { 0 };\n\n    // Pull CS low to start transaction\n    DS1722_CS_LOW();\n\n    // Send command and receive 2 bytes\n    for (int i = 0; i &lt; 3; i++) {\n        // Wait until TXE is set\n        while (!(SPIx-&gt;SR & SPI_SR_TXE));\n        *((__IO uint8_t *)&SPIx-&gt;DR) = tx_buf[i];\n\n        // Wait until RXNE is set\n        while (!(SPIx-&gt;SR & SPI_SR_RXNE));\n        rx_buf[i] = *((__IO uint8_t *)&SPIx-&gt;DR);\n    }\n\n    // Pull CS high to end transaction\n    DS1722_CS_HIGH();\n\n    // Combine MSB and LSB (12-bit resolution)\n    int16_t raw_temp = ((int16_t)rx_buf[1] &lt;&lt; 8) | rx_buf[2];\n    float temperature = raw_temp / 256.0f;\n\n    return temperature;\n}\n\nThe HTML code seemed to make a nice webpage. However I did not take the time to integrate it it with the sensing code.\nFor the SPI C code, it seemed to write reasonable code but I did not get it to work on my board. It appears to have used a few undefined macros and dubious CMSIS function that assume some other files exist with a certain structure.\nI think this could have been a good starting point for my code, but having already written my library it seems incompatible."
  },
  {
    "objectID": "labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design of an Internet of Things based temperature sensor and webpage\n\n\n\nTo record temperatures to display on the device’s webpage, I used a SPI temperature sensor which is written to for configuration and read from to get the temperature in fixed point format. The DS1722 temperature sensor’s data sheet can be found here\nFor this, I had to write a custom SPI library in C to configure the SPI registers on the MCU and drive data out and read data back.\n\n\n\nI designed the webpage to have button inputs to configure the number of bits of resolution via an HTTP request in the same way that the starter code turns a LED on and off.\n\n\n\nFigure 1: temperature sensor webpage\n\n\n\n\n\nThe C source code for this lab can by found on my github page\n\n\n\n\n\nFigure 2: Schematic of SPI temperature sensor circuit\n\n\n\n\n\nTo verify SPI transactions occured properl, I used a logic analyzer to show an SPI read and write between the MCU and temperature sensor\n\n\n\nFigure 3: Logic analyzer trace demonstrating proper SPI behavior\n\n\n\n\n\n\nMy design successfully displayed the temperature data from a DS1722 temperature sensor on a webpage with button selected 8 to 12 bit resolution.\nThis lab took me 10 hours\n\n\n\nI fed google AI mode the two promps, but It refused to produce any HTML code, so I tried Microsoft Copilot and it produced the following code:\nHTML Webpage\nchar* AI_page = \"\\\n&lt;!DOCTYPE html&gt;\\\n&lt;html lang=\\\"en\\\"&gt;\\\n&lt;head&gt;\\\n &lt;meta charset=\\\"UTF-8\\\" /&gt;\\\n &lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"/&gt;\\\n &lt;title&gt;Temperature Sensor Dashboard&lt;/title&gt;\\\n &lt;style&gt;\\\n   body {\\\n     font-family: 'Segoe UI', sans-serif;\\\n     background: #f4f7f9;\\\n     color: #333;\\\n     margin: 0;\\\n     padding: 0;\\\n   }\\\n   header {\\\n     background: #0078d4;\\\n     color: white;\\\n     padding: 1rem;\\\n     text-align: center;\\\n   }\\\n   .container {\\\n     max-width: 600px;\\\n     margin: 2rem auto;\\\n     padding: 2rem;\\\n     background: white;\\\n     border-radius: 8px;\\\n     box-shadow: 0 2px 8px rgba(0,0,0,0.1);\\\n   }\\\n   .section {\\\n     margin-bottom: 2rem;\\\n   }\\\n   .section h2 {\\\n     margin-bottom: 1rem;\\\n     font-size: 1.2rem;\\\n     color: #0078d4;\\\n   }\\\n   .temperature-display {\\\n     font-size: 2.5rem;\\\n     font-weight: bold;\\\n     text-align: center;\\\n     margin: 1rem 0;\\\n   }\\\n   .controls {\\\n     display: flex;\\\n     justify-content: space-between;\\\n     align-items: center;\\\n   }\\\n   .controls label {\\\n     margin-right: 0.5rem;\\\n   }\\\n   .led-toggle {\\\n     display: flex;\\\n     align-items: center;\\\n   }\\\n   button {\\\n     padding: 0.5rem 1rem;\\\n     background: #0078d4;\\\n     color: white;\\\n     border: none;\\\n     border-radius: 4px;\\\n     cursor: pointer;\\\n   }\\\n   button:hover {\\\n     background: #005fa3;\\\n   }\\\n   select {\\\n     padding: 0.4rem;\\\n   }\\\n &lt;/style&gt;\\\n&lt;/head&gt;\\\n&lt;body&gt;\\\n &lt;header&gt;\\\n   &lt;h1&gt;Temperature Sensor Dashboard&lt;/h1&gt;\\\n &lt;/header&gt;\\\n &lt;div class=\\\"container\\\"&gt;\\\n   &lt;div class=\\\"section\\\"&gt;\\\n     &lt;h2&gt;Current Temperature&lt;/h2&gt;\\\n     &lt;div class=\\\"temperature-display\\\" id=\\\"tempValue\\\"&gt;-- °C&lt;/div&gt;\\\n   &lt;/div&gt;\\\n   &lt;div class=\\\"section controls\\\"&gt;\\\n     &lt;div class=\\\"led-toggle\\\"&gt;\\\n       &lt;label for=\\\"ledSwitch\\\"&gt;LED:&lt;/label&gt;\\\n       &lt;button id=\\\"ledSwitch\\\"&gt;Toggle&lt;/button&gt;\\\n     &lt;/div&gt;\\\n     &lt;div&gt;\\\n       &lt;label for=\\\"precisionSelect\\\"&gt;Precision:&lt;/label&gt;\\\n       &lt;select id=\\\"precisionSelect\\\"&gt;\\\n         &lt;option value=\\\"0\\\"&gt;0 decimal&lt;/option&gt;\\\n         &lt;option value=\\\"1\\\" selected&gt;1 decimal&lt;/option&gt;\\\n         &lt;option value=\\\"2\\\"&gt;2 decimals&lt;/option&gt;\\\n       &lt;/select&gt;\\\n     &lt;/div&gt;\\\n   &lt;/div&gt;\\\n &lt;/div&gt;\\\n &lt;script&gt;\\\n   let ledState = false;\\\n   let precision = 1;\\\n   function fetchTemperature() {\\\n     // Simulate fetching temperature from a sensor\\\n     const rawTemp = 22.3456 + Math.random(); // Simulated temperature\\\n     const temp = rawTemp.toFixed(precision);\\\n     document.getElementById('tempValue').textContent = `${temp} °C`;\\\n   }\\\n   document.getElementById('ledSwitch').addEventListener('click', () =&gt; {\\\n     ledState = !ledState;\\\n     // Replace with actual API call to toggle LED\\\n     alert(`LED turned ${ledState ? 'ON' : 'OFF'}`);\\\n   });\\\n   document.getElementById('precisionSelect').addEventListener('change', (e) =&gt; {\\\n     precision = parseInt(e.target.value);\\\n     fetchTemperature();\\\n   });\\\n   // Initial fetch and update every 5 seconds\\\n   fetchTemperature();\\\n   setInterval(fetchTemperature, 5000);\\\n &lt;/script&gt;\\\n&lt;/body&gt;\\\n&lt;/html&gt;\";\n\n\n\nFigure 4: AI created webpage\n\n\nSPI code\n#include \"stm32l4xx.h\"  // CMSIS header for STM32L432KC\n\n#define DS1722_CS_PORT GPIOA\n#define DS1722_CS_PIN  GPIO_PIN_4\n\n#define DS1722_READ_TEMP_CMD 0x01  // Read temperature command\n\n// Helper macros to control CS pin\n#define DS1722_CS_LOW()  (DS1722_CS_PORT-&gt;BSRR = (uint32_t)DS1722_CS_PIN &lt;&lt; 16)\n#define DS1722_CS_HIGH() (DS1722_CS_PORT-&gt;BSRR = DS1722_CS_PIN)\n\nfloat DS1722_ReadTemperature(SPI_TypeDef *SPIx) {\n    uint8_t tx_buf[3] = { DS1722_READ_TEMP_CMD, 0x00, 0x00 };\n    uint8_t rx_buf[3] = { 0 };\n\n    // Pull CS low to start transaction\n    DS1722_CS_LOW();\n\n    // Send command and receive 2 bytes\n    for (int i = 0; i &lt; 3; i++) {\n        // Wait until TXE is set\n        while (!(SPIx-&gt;SR & SPI_SR_TXE));\n        *((__IO uint8_t *)&SPIx-&gt;DR) = tx_buf[i];\n\n        // Wait until RXNE is set\n        while (!(SPIx-&gt;SR & SPI_SR_RXNE));\n        rx_buf[i] = *((__IO uint8_t *)&SPIx-&gt;DR);\n    }\n\n    // Pull CS high to end transaction\n    DS1722_CS_HIGH();\n\n    // Combine MSB and LSB (12-bit resolution)\n    int16_t raw_temp = ((int16_t)rx_buf[1] &lt;&lt; 8) | rx_buf[2];\n    float temperature = raw_temp / 256.0f;\n\n    return temperature;\n}\n\nThe HTML code seemed to make a nice webpage. However I did not take the time to integrate it it with the sensing code.\nFor the SPI C code, it seemed to write reasonable code but I did not get it to work on my board. It appears to have used a few undefined macros and dubious CMSIS function that assume some other files exist with a certain structure.\nI think this could have been a good starting point for my code, but having already written my library it seems incompatible."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Getting Started",
    "section": "",
    "text": "This week we had the first 2 lectures for E155, covering course logistics and (System)Verilog syntax and idioms. I was especially exited to cover Verilog since I have become extremely familliar with the subtleties of the Language Reference Manual (LRM) over the past few months (especially the verification specific constructs)."
  },
  {
    "objectID": "posts/first-post.html#week-1-lectures",
    "href": "posts/first-post.html#week-1-lectures",
    "title": "Getting Started",
    "section": "",
    "text": "This week we had the first 2 lectures for E155, covering course logistics and (System)Verilog syntax and idioms. I was especially exited to cover Verilog since I have become extremely familliar with the subtleties of the Language Reference Manual (LRM) over the past few months (especially the verification specific constructs)."
  },
  {
    "objectID": "posts/first-post.html#in-the-lab",
    "href": "posts/first-post.html#in-the-lab",
    "title": "Getting Started",
    "section": "In the Lab",
    "text": "In the Lab\nWhile there were no technical deliverables for this week, I still spent a few hours in the lab soldering all components and connectors to the PCB motherboard. I am not the most skilled at soldering, and I did not have previous experience with surface mounted soldering so this was a bit of a challenge. After much slouching, a considerable amount of solder wick, and a few backwards idodes, I have now finished this task and can move onto lab 1!"
  },
  {
    "objectID": "posts/first-post.html#goal-setting",
    "href": "posts/first-post.html#goal-setting",
    "title": "Getting Started",
    "section": "Goal Setting",
    "text": "Goal Setting\nI am extremely excited to take this class, as I wanted to take it sooner but did not have the time in my schedule. My primary goal is to expand my scope as an electrical engineer beyone ASIC RTL and DV, and into the realm of embedded systems. My secondary goal is to have fun with this class and enjoy my final year at Mudd. I really enjoyed E80 and the E85 microprocessor based labs, so I know that I will enjoy this course now that I have the chance to take it."
  }
]