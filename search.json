[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "E155 Course Website"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification process for a 4x4 keypad matrix with TDM 7-segment display outputs\n\n\n\nTo make block level verification as simple as possible, I factored the design into three FSMs that each handle a small set of tasks, with handshakes between them where necessary.\nI did block formal verification for this project using SymbiYosys. With this tool, I proved that a set of design assertions were impossible to break for each major design element. For system level verification, I produces a simple simulation testbench to demonstrate the glue logic between the formally verified blocks.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure with the three major FSMs, an encoder to convert row and column indecis into a hex value, and the time division multiplexer circuit derived from lab 2\n\n\n\n\n\n\nfigure 2: controller FSM State Transition Diagram\n\n\n\n\n\nfigure 3: controller FSM State Transition Table\n\n\n\n\n\nfigure 4: row driver FSM State Transition Diagram\n\n\n\n\n\nfigure 5: row driver FSM State Transition Table\n\n\n\n\n\nfigure 6: debouncing FSM State Transition Diagram\n\n\n\n\n\nfigure 7: debouncing FSM State Transition Table\n\n\nFigures 2-7 demonstrate the design of the three FSMs seen in the block diagram in figure 1\n\n\n\n\n\n\nFigure 8: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 8 demonstrates the phsyical hardware layout of the design, with the 4x4 keypad, 7-segment display, PNP transistors, pull down resistors, and current limiting resistors.\n\n\n\nFor this lab we had 3 different resistor values to calculate.\nFirst, we needed the current limiting resistors for the 7-segment LED arrays driven by the PNP resistors. For safety, I aimed for ~3 mA. Red LEDs have a voltage drop of ~1.8V and there is a voltage drop of ~0.2V between the collector and emitter of the PNP transister, per the datasheet, so we get the following calculation\n\\[\nR = \\frac{3.3V - 0.2V - 1.8V}{3mA} = 433 \\Omega\n\\]\nNext, we have the resistor binding the base of the PNP transistor to the IO pin that powers each 7-segment display. Since the upper voltage is 3.3V going into a silicon diode that connects to the base, the voltage at the base is 0.7V lower or 2.6V. When the pin that is bridged to this terminal by a resistor is low, we wish to limit the current into the pin, so we aim for a large resistor. If we aim for around 3 mA of current, then we get the following equation for R:\n\\[\nR = \\frac{3.3V - 0.7V}{3mA} = 866 \\Omega\n\\]\nTo be extra safe and make use of readily available components, I used 680 Ohms for the current limiting resistors and 1 kOhms for the resistors connected to the PNPs.\nFinally, for the external pull down resistors I chose 680 Ohms since this value would safely be low enough to prevent bringing the default pin voltage above the lower logic level. This likely could have been increased to save power, but since that wasn’t a particular concern, I chose this lower value to be safe.\n\n\n\n\n\n\n\n\n\nfigure 9: Controller FSM Formal Verification Results\n\n\n\n\n\nfigure 10: Row Driver FSM Formal Verification Results\n\n\n\n\n\nfigure 11: Debouncer FSM Formal Verification Results\n\n\n\n\n\nfigure 12: Keypad Encoder Formal Verification Results\n\n\nThese formal verification results demonstrate that each major submodule adheres to a set of application specific design properties for all time, proving that they work as expected.\n\n\n\nfigure 13: Top Module Simulation Waveforms\n\n\n\n\n\nfigure 14: Top Module Simulation Output\n\n\n\n\n\nEvery button was checker for proper behavior. When one button was pressed, no other buttons affected the display. Additionally, I observed that the two segments did no flicker or bleed into one another, and were reletively bright.\n\n\n\n\nI was able to design a matrix keypad driver circuit to read button presses from a real-world user. I brushed up on my synchronous design skills and my ability to formally describe the intended behavior of a sequential design without explicit test cases, as to be able to use formal verification.\nI spent around 35 hours on this lab making sure my design meets all requirements\n\n\n\nFirst, I gave Microsoft Copilot the following prompt:\n“Target device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\nA clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.”\nInitially, it did not synthesize due to the use of a $clog2 function call for a cute one-liner priority encoder. After pointing this out, it make a custom SystemVerilog function to perform this functionality. After this change, it synthesized with the following netlist viewer result:\n\n\n\nfigure 15: First AI Prototype\n\n\nNext, I gave this LLM the following three prompts back-to-back:\n“Target device: Lattice iCE40 UP5K FPGA.\nOverall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\nCurrent Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\nWhen a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.”\n“Target device: Lattice iCE40 UP5K FPGA.\nWrite a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\nIterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.”\n“Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\nWrite a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\nUpdate the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.”\nAgain, it did not synthesize initially since it was missing a keypad encoder module. Once this was pointed out and corrected, I got the following:\n\n\n\nfigure 16: First AI Prototype\n\n\nThese designs are prett similar to mine, but were done in a small fraction of the time. I would be curious to see how well they did on the physical hardware, as there are many subtle hardware edge cases that I am not sure the AI model is considering in producing this code.\nOverall I am impressed with its performance, but I am also not shocked it missed synthesis issues and came up with nonstandard solutions."
  },
  {
    "objectID": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "href": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification process for a 4x4 keypad matrix with TDM 7-segment display outputs\n\n\n\nTo make block level verification as simple as possible, I factored the design into three FSMs that each handle a small set of tasks, with handshakes between them where necessary.\nI did block formal verification for this project using SymbiYosys. With this tool, I proved that a set of design assertions were impossible to break for each major design element. For system level verification, I produces a simple simulation testbench to demonstrate the glue logic between the formally verified blocks.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure with the three major FSMs, an encoder to convert row and column indecis into a hex value, and the time division multiplexer circuit derived from lab 2\n\n\n\n\n\n\nfigure 2: controller FSM State Transition Diagram\n\n\n\n\n\nfigure 3: controller FSM State Transition Table\n\n\n\n\n\nfigure 4: row driver FSM State Transition Diagram\n\n\n\n\n\nfigure 5: row driver FSM State Transition Table\n\n\n\n\n\nfigure 6: debouncing FSM State Transition Diagram\n\n\n\n\n\nfigure 7: debouncing FSM State Transition Table\n\n\nFigures 2-7 demonstrate the design of the three FSMs seen in the block diagram in figure 1\n\n\n\n\n\n\nFigure 8: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 8 demonstrates the phsyical hardware layout of the design, with the 4x4 keypad, 7-segment display, PNP transistors, pull down resistors, and current limiting resistors.\n\n\n\nFor this lab we had 3 different resistor values to calculate.\nFirst, we needed the current limiting resistors for the 7-segment LED arrays driven by the PNP resistors. For safety, I aimed for ~3 mA. Red LEDs have a voltage drop of ~1.8V and there is a voltage drop of ~0.2V between the collector and emitter of the PNP transister, per the datasheet, so we get the following calculation\n\\[\nR = \\frac{3.3V - 0.2V - 1.8V}{3mA} = 433 \\Omega\n\\]\nNext, we have the resistor binding the base of the PNP transistor to the IO pin that powers each 7-segment display. Since the upper voltage is 3.3V going into a silicon diode that connects to the base, the voltage at the base is 0.7V lower or 2.6V. When the pin that is bridged to this terminal by a resistor is low, we wish to limit the current into the pin, so we aim for a large resistor. If we aim for around 3 mA of current, then we get the following equation for R:\n\\[\nR = \\frac{3.3V - 0.7V}{3mA} = 866 \\Omega\n\\]\nTo be extra safe and make use of readily available components, I used 680 Ohms for the current limiting resistors and 1 kOhms for the resistors connected to the PNPs.\nFinally, for the external pull down resistors I chose 680 Ohms since this value would safely be low enough to prevent bringing the default pin voltage above the lower logic level. This likely could have been increased to save power, but since that wasn’t a particular concern, I chose this lower value to be safe.\n\n\n\n\n\n\n\n\n\nfigure 9: Controller FSM Formal Verification Results\n\n\n\n\n\nfigure 10: Row Driver FSM Formal Verification Results\n\n\n\n\n\nfigure 11: Debouncer FSM Formal Verification Results\n\n\n\n\n\nfigure 12: Keypad Encoder Formal Verification Results\n\n\nThese formal verification results demonstrate that each major submodule adheres to a set of application specific design properties for all time, proving that they work as expected.\n\n\n\nfigure 13: Top Module Simulation Waveforms\n\n\n\n\n\nfigure 14: Top Module Simulation Output\n\n\n\n\n\nEvery button was checker for proper behavior. When one button was pressed, no other buttons affected the display. Additionally, I observed that the two segments did no flicker or bleed into one another, and were reletively bright.\n\n\n\n\nI was able to design a matrix keypad driver circuit to read button presses from a real-world user. I brushed up on my synchronous design skills and my ability to formally describe the intended behavior of a sequential design without explicit test cases, as to be able to use formal verification.\nI spent around 35 hours on this lab making sure my design meets all requirements\n\n\n\nFirst, I gave Microsoft Copilot the following prompt:\n“Target device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\nA clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.”\nInitially, it did not synthesize due to the use of a $clog2 function call for a cute one-liner priority encoder. After pointing this out, it make a custom SystemVerilog function to perform this functionality. After this change, it synthesized with the following netlist viewer result:\n\n\n\nfigure 15: First AI Prototype\n\n\nNext, I gave this LLM the following three prompts back-to-back:\n“Target device: Lattice iCE40 UP5K FPGA.\nOverall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\nCurrent Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\nWhen a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.”\n“Target device: Lattice iCE40 UP5K FPGA.\nWrite a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\nIterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.”\n“Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\nWrite a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\nUpdate the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.”\nAgain, it did not synthesize initially since it was missing a keypad encoder module. Once this was pointed out and corrected, I got the following:\n\n\n\nfigure 16: First AI Prototype\n\n\nThese designs are prett similar to mine, but were done in a small fraction of the time. I would be curious to see how well they did on the physical hardware, as there are many subtle hardware edge cases that I am not sure the AI model is considering in producing this code.\nOverall I am impressed with its performance, but I am also not shocked it missed synthesis issues and came up with nonstandard solutions."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification of a simple FPGA design to become familiar with the E155 toolflow. The design contains a seven segment display decoder, a simple digital oscillator, and a few logic gates.\n\n\n\nThe core part of the design is a 4 to 7 bit decoder for controlling a 7 segment display to display the hex value of a 4 bit input signal. This was created using behavioral SystemVerilog code and was verfified with a simple testbench, where the input signal was incremented from 0000 to 1111 and values for each bit of the decoded output was checked against the expected stream of bits. In hindsight, this was likely a convoluted approach to verification, but since the module is just a truth table, using standard test vectors would essentially mean copying the RTL code to see if it matched itself.\nFor the top level module, the seven segment decoder was instantiated alongside a high speed oscillator (HSOSC) to generate a 48 MHz clock. This clock was fed into a digital clock divider where a constant P is added to a 32 bit register on each rising edge of the fast clock, causing the most significant bit to toggle with a frequency given by the following equation:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 32 bits, F = 48 MHz, and f = 2.4 Hz, we can solve for P = 215 to achieve the desired frequency.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the 7:4 decoder, two logic gates, high frequency clock, and clock divider\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the seven LEDs of the seven segment display with current limiting resistors, the three on-board LEDs driven by the design, and the input DIP switches.\n\n\n\nFrom the data sheet the LED display has a voltage drop of roughly 2 volts. Since we are using a 3.3 Volt supply and the FPGA pins have an 8 mA current limit, we can set up the following equation for the minimum current limiting resistor value:\n\\[\nR = \\frac{3.3V - 2V}{8mA} = 165 \\Omega\n\\]\nHowever, to be extra careful not to burn out my LED display, I used a factor of safety of 2 and used 330 Ohm resistors.\n\n\n\n\n\n\n\n\n\nFigure 3: Testbench simulation waveforms from decoder module\n\n\n\n\n\nFigure 4: Successful testbench output from seven segment decoder simulation\n\n\n\n\n\nFigure 5: Testbench Simulation of top level module\n\n\n\n\n\nFigure 6: Successful testbench output from top level simulation\n\n\nThe design was shown to meet all specifications in simulation, except the blinking LED which was tested in hardware.\n\n\n\nThe seven segment display and two gate-driven LEDs responded to input DIP switches in accordance with the design spec\n\n\n\nFigure 7: Photograph of oscilliscope measuring ~2.4Hz LED blinking\n\n\nFigure 7 shows the corrent timing of the blinking LED in hardware.\n\n\n\n\nI was able to set up the E155 toolchain and demonstrate it on this moderately simple lab. I look forward to building experience with this flow on future labs. I spent roughly 15 hours on this lab.\n\n\n\nI gave Microsoft Bing the following prompt to see if it could replicate some of my work:\n“Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nInitally, it gave me the following code:\nmodule led_blinker_2hz (\n    output logic led\n);\n\n    // Internal oscillator output\n    logic clk;\n    logic clk_en;\n\n    // Instantiate the high-frequency oscillator (typically 48 MHz)\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\")  // No division: 48 MHz\n    ) hf_osc_inst (\n        .CLKHFEN(clk_en),\n        .CLKHFPU(clk_en),\n        .CLKHF(clk)\n    );\n\n    // Enable the oscillator\n    initial clk_en = 1'b1;\n\n    // Counter to divide 48 MHz down to 2 Hz\n    // 48,000,000 / 2 = 24,000,000 clock cycles per toggle\n    localparam int COUNT_MAX = 24_000_000;\n    logic [$clog2(COUNT_MAX)-1:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        if (counter == COUNT_MAX - 1) begin\n            counter &lt;= 0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\nThis did not synthesize since it used a different clock generator module, SB_HFOSC. When I asked it to correct the error, it insisted that it was related to a missing package. However, once I changed this module to HSOSC, it synthesized just fine.\nThis prototype made me question the landscape of digital design. It seems that these models have gotten very good at the big picture, and only now struggle with the software specific details."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification of a simple FPGA design to become familiar with the E155 toolflow. The design contains a seven segment display decoder, a simple digital oscillator, and a few logic gates.\n\n\n\nThe core part of the design is a 4 to 7 bit decoder for controlling a 7 segment display to display the hex value of a 4 bit input signal. This was created using behavioral SystemVerilog code and was verfified with a simple testbench, where the input signal was incremented from 0000 to 1111 and values for each bit of the decoded output was checked against the expected stream of bits. In hindsight, this was likely a convoluted approach to verification, but since the module is just a truth table, using standard test vectors would essentially mean copying the RTL code to see if it matched itself.\nFor the top level module, the seven segment decoder was instantiated alongside a high speed oscillator (HSOSC) to generate a 48 MHz clock. This clock was fed into a digital clock divider where a constant P is added to a 32 bit register on each rising edge of the fast clock, causing the most significant bit to toggle with a frequency given by the following equation:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 32 bits, F = 48 MHz, and f = 2.4 Hz, we can solve for P = 215 to achieve the desired frequency.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the 7:4 decoder, two logic gates, high frequency clock, and clock divider\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the seven LEDs of the seven segment display with current limiting resistors, the three on-board LEDs driven by the design, and the input DIP switches.\n\n\n\nFrom the data sheet the LED display has a voltage drop of roughly 2 volts. Since we are using a 3.3 Volt supply and the FPGA pins have an 8 mA current limit, we can set up the following equation for the minimum current limiting resistor value:\n\\[\nR = \\frac{3.3V - 2V}{8mA} = 165 \\Omega\n\\]\nHowever, to be extra careful not to burn out my LED display, I used a factor of safety of 2 and used 330 Ohm resistors.\n\n\n\n\n\n\n\n\n\nFigure 3: Testbench simulation waveforms from decoder module\n\n\n\n\n\nFigure 4: Successful testbench output from seven segment decoder simulation\n\n\n\n\n\nFigure 5: Testbench Simulation of top level module\n\n\n\n\n\nFigure 6: Successful testbench output from top level simulation\n\n\nThe design was shown to meet all specifications in simulation, except the blinking LED which was tested in hardware.\n\n\n\nThe seven segment display and two gate-driven LEDs responded to input DIP switches in accordance with the design spec\n\n\n\nFigure 7: Photograph of oscilliscope measuring ~2.4Hz LED blinking\n\n\nFigure 7 shows the corrent timing of the blinking LED in hardware.\n\n\n\n\nI was able to set up the E155 toolchain and demonstrate it on this moderately simple lab. I look forward to building experience with this flow on future labs. I spent roughly 15 hours on this lab.\n\n\n\nI gave Microsoft Bing the following prompt to see if it could replicate some of my work:\n“Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nInitally, it gave me the following code:\nmodule led_blinker_2hz (\n    output logic led\n);\n\n    // Internal oscillator output\n    logic clk;\n    logic clk_en;\n\n    // Instantiate the high-frequency oscillator (typically 48 MHz)\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\")  // No division: 48 MHz\n    ) hf_osc_inst (\n        .CLKHFEN(clk_en),\n        .CLKHFPU(clk_en),\n        .CLKHF(clk)\n    );\n\n    // Enable the oscillator\n    initial clk_en = 1'b1;\n\n    // Counter to divide 48 MHz down to 2 Hz\n    // 48,000,000 / 2 = 24,000,000 clock cycles per toggle\n    localparam int COUNT_MAX = 24_000_000;\n    logic [$clog2(COUNT_MAX)-1:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        if (counter == COUNT_MAX - 1) begin\n            counter &lt;= 0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\nThis did not synthesize since it used a different clock generator module, SB_HFOSC. When I asked it to correct the error, it insisted that it was related to a missing package. However, once I changed this module to HSOSC, it synthesized just fine.\nThis prototype made me question the landscape of digital design. It seems that these models have gotten very good at the big picture, and only now struggle with the software specific details."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Getting Started\n\n\nFirst Steps into E155\n\n\n\n\n\nAug 29, 2025\n\n\nCorey Hickson\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Corey Hickson is a class of 2026 Engineering Major at Harvey Mudd College with background in design verification and digital design. As a VLSI research fellow with the Clay-Wolkin Fellowship at Harvey Mudd, he has conducted core level functional testing and coverage collection of a RISC-V processor core. While interning at Skyworks Solutions in the summer of 2025, he conducted whole core level formal verification of a different RISC-V processor core. Corey looks forward to the 2025-26 HRL Laboratories engineering clinic project, where he and his team will work towards producing a C program to emulate a mixed analog-digital quantum qubit control board. After graduation, he will return to Skyworks as a Design Verification Engineer 1 to continue his work in formal verification from the past summer."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification process for a time division multiplexed 7-segment display pair.\n\n\n\nThe design uses a single time-multiplexed 7 segment decoder that switches between two sets of hex nibble inputs at 60 Hz. This is done by dividing a 48 MHz clock to 120 Hz, and using this slow clock to drive a toggle flop to divide down to 60 Hz (called the select line). The select line switches between the two inputs and two power pins and the slow clock triggers flops on the output to ensure clean transitions between the two displays\nI did formal verification for this project using SymbiYosys. For this, when synthesizing for formal verification there is an external clock input that takes the place of the slow clock. I proved that a set of design assertions cannot be broken for 30 cycles, and that there is no trace through the design that breaks an assertion on the 1000th cycle, so by interpolating we can declare the design bug free with respect to these assertions.\nFor the slow clock generation, I used the same formula as last week with a different target frequency:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 24 bits, F = 48 MHz, and f = 120 Hz, we can solve for P = 42 to achieve the desired frequency.\nSince this was not covered in formal verification, this portion of the design was verified with a simple testbench simulation.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the single 7:4 decoder, high frequency clock, clock divider, and a few registers and gates\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the two 7-segment displays, 5 additional LEDs, 4 external DIP switches, and 2 PNP transistors.\n\n\n\nFor this lab we had 3 different resistor values to calculate.\nFirst, we needed the current limiting resistors for the single LEDs driven by IO pins on the FPGA. From the FPGA datasheet, the FPGA can ouput 3.3V on an IO pin at a maximum of 8 mA of current. For safety, I aimed for ~3 mA. Red LEDs have a voltage drop of ~1.8V, so we get the following equation:\n\\[\nR = \\frac{3.3V - 1.8V}{3mA} = 500 \\Omega\n\\]\nNext, we have the current limiting resistors for the 7-segment LED arrays. These follow the same general format as the previous calculation, but since there is a voltage drop of ~0.2V between the collector and emitter of the PNP transister, per the datasheet, the calculation becomes the following:\n\\[\nR = \\frac{3.3V - 0.2V - 1.8V}{3mA} = 433 \\Omega\n\\]\nFinally, we have the resistor binding the base of the PNP transistor to the IO pin that powers each 7-segment display. Since the upper voltage is 3.3V going into a silicon diode that connects to the base, the voltage at the base is 0.7V lower or 2.6V. When the pin that is bridged to this terminal by a resistor is low, we wish to limit the current into the pin, so we aim for a large resistor. If we aim for around 3 mA of current, then we get the following equation for R:\n\\[\nR = \\frac{3.3V - 0.7V - 0}{3mA} = 866 \\Omega\n\\]\nTo be extra safe and make use of readily available components, I used 680 Ohms for the current limiting resistors and 1 kOhms for the resistors connected to the PNPs.\n\n\n\n\n\n\n\n\n\nFigure 3: Bounded formal proof results (depth of 30 cycles)\n\n\n\n\n\nFigure 4: Deep formal bug hunt results (checking all ways to reach cycle 1000)\n\n\n\n\n\nFigure 5: Simulation waveforms for clock verification\n\n\n\n\n\nFigure 6: Simulation output for clock verification\n\n\nFormal verification proved that the design met all cycle dependant specifications (based on assumptions about the clock signal), and the simple simulation demonstrated expected behavior of the clock.\n\n\n\nThe input space was sampled at random to check a subset of the design functionality. Additionally, I observed that the two segments did no flicker or bleed into one another, and were reletively bright.\n\n\n\n\nI was able to design a time division multiplexing circuit to have two design elements share a single piece of expensive harware. I brushed up on my synchronous design skills and my ability to formally describe the intended behavior of a sequential design without explicit test cases, as to be able to use formal verification.\nI spent around 15 hours on this lab\n\n\n\nI gave google’s “AI Mode” search engine the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”\nAnd it produced the commented out code in the AI section of the lab repository here. This design has the following structure:\n\n\n\nFigure 7: First AI design netlist viewer\n\n\nThis initially had a minor bug where the dimensions of a logic vector were given after the name. Once this was corrected, the design synthesized without issue.\nNext, I gave a new AI session my files from lab 1 and the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.”\nThis time, there were no issues synthesizing and it produced the following design:\n\n\n\nFigure 7: Second AI design netlist viewer\n\n\nThis is similar to my design for this lab, but without the registers on the output side.\nThis activity led me to question the necessity of the registers I added at the output, as the LLM did not feel the need to add them in its version of the design, which otherwiss lines up with mine. I am again impressed by the ability of LLMs to carry out digital design. I am beginning to wonder if they will come after my Design Verification career…"
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification process for a time division multiplexed 7-segment display pair.\n\n\n\nThe design uses a single time-multiplexed 7 segment decoder that switches between two sets of hex nibble inputs at 60 Hz. This is done by dividing a 48 MHz clock to 120 Hz, and using this slow clock to drive a toggle flop to divide down to 60 Hz (called the select line). The select line switches between the two inputs and two power pins and the slow clock triggers flops on the output to ensure clean transitions between the two displays\nI did formal verification for this project using SymbiYosys. For this, when synthesizing for formal verification there is an external clock input that takes the place of the slow clock. I proved that a set of design assertions cannot be broken for 30 cycles, and that there is no trace through the design that breaks an assertion on the 1000th cycle, so by interpolating we can declare the design bug free with respect to these assertions.\nFor the slow clock generation, I used the same formula as last week with a different target frequency:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 24 bits, F = 48 MHz, and f = 120 Hz, we can solve for P = 42 to achieve the desired frequency.\nSince this was not covered in formal verification, this portion of the design was verified with a simple testbench simulation.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the single 7:4 decoder, high frequency clock, clock divider, and a few registers and gates\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the two 7-segment displays, 5 additional LEDs, 4 external DIP switches, and 2 PNP transistors.\n\n\n\nFor this lab we had 3 different resistor values to calculate.\nFirst, we needed the current limiting resistors for the single LEDs driven by IO pins on the FPGA. From the FPGA datasheet, the FPGA can ouput 3.3V on an IO pin at a maximum of 8 mA of current. For safety, I aimed for ~3 mA. Red LEDs have a voltage drop of ~1.8V, so we get the following equation:\n\\[\nR = \\frac{3.3V - 1.8V}{3mA} = 500 \\Omega\n\\]\nNext, we have the current limiting resistors for the 7-segment LED arrays. These follow the same general format as the previous calculation, but since there is a voltage drop of ~0.2V between the collector and emitter of the PNP transister, per the datasheet, the calculation becomes the following:\n\\[\nR = \\frac{3.3V - 0.2V - 1.8V}{3mA} = 433 \\Omega\n\\]\nFinally, we have the resistor binding the base of the PNP transistor to the IO pin that powers each 7-segment display. Since the upper voltage is 3.3V going into a silicon diode that connects to the base, the voltage at the base is 0.7V lower or 2.6V. When the pin that is bridged to this terminal by a resistor is low, we wish to limit the current into the pin, so we aim for a large resistor. If we aim for around 3 mA of current, then we get the following equation for R:\n\\[\nR = \\frac{3.3V - 0.7V - 0}{3mA} = 866 \\Omega\n\\]\nTo be extra safe and make use of readily available components, I used 680 Ohms for the current limiting resistors and 1 kOhms for the resistors connected to the PNPs.\n\n\n\n\n\n\n\n\n\nFigure 3: Bounded formal proof results (depth of 30 cycles)\n\n\n\n\n\nFigure 4: Deep formal bug hunt results (checking all ways to reach cycle 1000)\n\n\n\n\n\nFigure 5: Simulation waveforms for clock verification\n\n\n\n\n\nFigure 6: Simulation output for clock verification\n\n\nFormal verification proved that the design met all cycle dependant specifications (based on assumptions about the clock signal), and the simple simulation demonstrated expected behavior of the clock.\n\n\n\nThe input space was sampled at random to check a subset of the design functionality. Additionally, I observed that the two segments did no flicker or bleed into one another, and were reletively bright.\n\n\n\n\nI was able to design a time division multiplexing circuit to have two design elements share a single piece of expensive harware. I brushed up on my synchronous design skills and my ability to formally describe the intended behavior of a sequential design without explicit test cases, as to be able to use formal verification.\nI spent around 15 hours on this lab\n\n\n\nI gave google’s “AI Mode” search engine the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”\nAnd it produced the commented out code in the AI section of the lab repository here. This design has the following structure:\n\n\n\nFigure 7: First AI design netlist viewer\n\n\nThis initially had a minor bug where the dimensions of a logic vector were given after the name. Once this was corrected, the design synthesized without issue.\nNext, I gave a new AI session my files from lab 1 and the following prompt:\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.”\nThis time, there were no issues synthesizing and it produced the following design:\n\n\n\nFigure 7: Second AI design netlist viewer\n\n\nThis is similar to my design for this lab, but without the registers on the output side.\nThis activity led me to question the necessity of the registers I added at the output, as the LLM did not feel the need to add them in its version of the design, which otherwiss lines up with mine. I am again impressed by the ability of LLMs to carry out digital design. I am beginning to wonder if they will come after my Design Verification career…"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Getting Started",
    "section": "",
    "text": "This week we had the first 2 lectures for E155, covering course logistics and (System)Verilog syntax and idioms. I was especially exited to cover Verilog since I have become extremely familliar with the subtleties of the Language Reference Manual (LRM) over the past few months (especially the verification specific constructs)."
  },
  {
    "objectID": "posts/first-post.html#week-1-lectures",
    "href": "posts/first-post.html#week-1-lectures",
    "title": "Getting Started",
    "section": "",
    "text": "This week we had the first 2 lectures for E155, covering course logistics and (System)Verilog syntax and idioms. I was especially exited to cover Verilog since I have become extremely familliar with the subtleties of the Language Reference Manual (LRM) over the past few months (especially the verification specific constructs)."
  },
  {
    "objectID": "posts/first-post.html#in-the-lab",
    "href": "posts/first-post.html#in-the-lab",
    "title": "Getting Started",
    "section": "In the Lab",
    "text": "In the Lab\nWhile there were no technical deliverables for this week, I still spent a few hours in the lab soldering all components and connectors to the PCB motherboard. I am not the most skilled at soldering, and I did not have previous experience with surface mounted soldering so this was a bit of a challenge. After much slouching, a considerable amount of solder wick, and a few backwards idodes, I have now finished this task and can move onto lab 1!"
  },
  {
    "objectID": "posts/first-post.html#goal-setting",
    "href": "posts/first-post.html#goal-setting",
    "title": "Getting Started",
    "section": "Goal Setting",
    "text": "Goal Setting\nI am extremely excited to take this class, as I wanted to take it sooner but did not have the time in my schedule. My primary goal is to expand my scope as an electrical engineer beyone ASIC RTL and DV, and into the realm of embedded systems. My secondary goal is to have fun with this class and enjoy my final year at Mudd. I really enjoyed E80 and the E85 microprocessor based labs, so I know that I will enjoy this course now that I have the chance to take it."
  }
]