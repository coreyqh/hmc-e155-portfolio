[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "E155 Course Website"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification of a simple FPGA design to become familiar with the E155 toolflow. The design contains a seven segment display decoder, a simple digital oscillator, and a few logic gates.\n\n\n\nThe core part of the design is a 4 to 7 bit decoder for controlling a 7 segment display to display the hex value of a 4 bit input signal. This was created using behavioral SystemVerilog code and was verfified with a simple testbench, where the input signal was incremented from 0000 to 1111 and values for each bit of the decoded output was checked against the expected stream of bits. In hindsight, this was likely a convoluted approach to verification, but since the module is just a truth table, using standard test vectors would essentially mean copying the RTL code to see if it matched itself.\nFor the top level module, the seven segment decoder was instantiated alongside a high speed oscillator (HSOSC) to generate a 48 MHz clock. This clock was fed into a digital clock divider where a constant P is added to a 32 bit register on each rising edge of the fast clock, causing the most significant bit to toggle with a frequency given by the following equation:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 32 bits, F = 48 MHz, and f = 2.4 Hz, we can solve for P = 215 to achieve the desired frequency.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the 7:4 decoder, two logic gates, high frequency clock, and clock divider\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the seven LEDs of the seven segment display with current limiting resistors, the three on-board LEDs driven by the design, and the input DIP switches.\n\n\n\nFrom the data sheet the LED display has a voltage drop of roughly 2 volts. Since we are using a 3.3 Volt supply and the FPGA pins have an 8 mA current limit, we can set up the following equation for the minimum current limiting resistor value:\n\\[\nR = \\frac{3.3V - 2V}{8mA} = 165 \\Omega\n\\]\nHowever, to be extra careful not to burn out my LED display, I used a factor of safety of 2 and used 330 Ohm resistors.\n\n\n\n\n\n\n\n\n\nFigure 3: Testbench simulation waveforms from decoder module\n\n\n\n\n\nFigure 4: Successful testbench output from seven segment decoder simulation\n\n\n\n\n\nFigure 5: Testbench Simulation of top level module\n\n\n\n\n\nFigure 6: Successful testbench output from top level simulation\n\n\nThe design was shown to meet all specifications in simulation, except the blinking LED which was tested in hardware.\n\n\n\nThe seven segment display and two gate-driven LEDs responded to input DIP switches in accordance with the design spec\n\n\n\nFigure 7: Photograph of oscilliscope measuring ~2.4Hz LED blinking\n\n\nFigure 7 shows the corrent timing of the blinking LED in hardware.\n\n\n\n\nI was able to set up the E155 toolchain and demonstrate it on this moderately simple lab. I look forward to building experience with this flow on future labs. I spent roughly 15 hours on this lab.\n\n\n\nI gave Microsoft Bing the following prompt to see if it could replicate some of my work:\n“Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nInitally, it gave me the following code:\nmodule led_blinker_2hz (\n    output logic led\n);\n\n    // Internal oscillator output\n    logic clk;\n    logic clk_en;\n\n    // Instantiate the high-frequency oscillator (typically 48 MHz)\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\")  // No division: 48 MHz\n    ) hf_osc_inst (\n        .CLKHFEN(clk_en),\n        .CLKHFPU(clk_en),\n        .CLKHF(clk)\n    );\n\n    // Enable the oscillator\n    initial clk_en = 1'b1;\n\n    // Counter to divide 48 MHz down to 2 Hz\n    // 48,000,000 / 2 = 24,000,000 clock cycles per toggle\n    localparam int COUNT_MAX = 24_000_000;\n    logic [$clog2(COUNT_MAX)-1:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        if (counter == COUNT_MAX - 1) begin\n            counter &lt;= 0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\nThis did not synthesize since it used a different clock generator module, SB_HFOSC. When I asked it to correct the error, it insisted that it was related to a missing package. However, once I changed this module to HSOSC, it synthesized just fine.\nThis prototype made me question the landscape of digital design. It seems that these models have gotten very good at the big picture, and only now struggle with the software specific details."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This report outlines the design and verification of a simple FPGA design to become familiar with the E155 toolflow. The design contains a seven segment display decoder, a simple digital oscillator, and a few logic gates.\n\n\n\nThe core part of the design is a 4 to 7 bit decoder for controlling a 7 segment display to display the hex value of a 4 bit input signal. This was created using behavioral SystemVerilog code and was verfified with a simple testbench, where the input signal was incremented from 0000 to 1111 and values for each bit of the decoded output was checked against the expected stream of bits. In hindsight, this was likely a convoluted approach to verification, but since the module is just a truth table, using standard test vectors would essentially mean copying the RTL code to see if it matched itself.\nFor the top level module, the seven segment decoder was instantiated alongside a high speed oscillator (HSOSC) to generate a 48 MHz clock. This clock was fed into a digital clock divider where a constant P is added to a 32 bit register on each rising edge of the fast clock, causing the most significant bit to toggle with a frequency given by the following equation:\n\\[\nf = \\frac{P \\cdot F}{2^n}\n\\]\nFilling in n = 32 bits, F = 48 MHz, and f = 2.4 Hz, we can solve for P = 215 to achieve the desired frequency.\n\n\n\nThe SystemVerilog source code for this lab can by found on my github page\n\n\n\n\n\nFigure 1: Top level block diagram\n\n\nThe block diagram in Figure 1 demonstrates the design structure, with the 7:4 decoder, two logic gates, high frequency clock, and clock divider\n\n\n\n\n\n\nFigure 2: schematic of physical breadboard circuit\n\n\nThe schematic in Figure 2 demonstrates the phsyical hardware layout of the design, with the seven LEDs of the seven segment display with current limiting resistors, the three on-board LEDs driven by the design, and the input DIP switches.\n\n\n\nFrom the data sheet the LED display has a voltage drop of roughly 2 volts. Since we are using a 3.3 Volt supply and the FPGA pins have an 8 mA current limit, we can set up the following equation for the minimum current limiting resistor value:\n\\[\nR = \\frac{3.3V - 2V}{8mA} = 165 \\Omega\n\\]\nHowever, to be extra careful not to burn out my LED display, I used a factor of safety of 2 and used 330 Ohm resistors.\n\n\n\n\n\n\n\n\n\nFigure 3: Testbench simulation waveforms from decoder module\n\n\n\n\n\nFigure 4: Successful testbench output from seven segment decoder simulation\n\n\n\n\n\nFigure 5: Testbench Simulation of top level module\n\n\n\n\n\nFigure 6: Successful testbench output from top level simulation\n\n\nThe design was shown to meet all specifications in simulation, except the blinking LED which was tested in hardware.\n\n\n\nThe seven segment display and two gate-driven LEDs responded to input DIP switches in accordance with the design spec\n\n\n\nFigure 7: Photograph of oscilliscope measuring ~2.4Hz LED blinking\n\n\nFigure 7 shows the corrent timing of the blinking LED in hardware.\n\n\n\n\nI was able to set up the E155 toolchain and demonstrate it on this moderately simple lab. I look forward to building experience with this flow on future labs. I spent roughly 15 hours on this lab.\n\n\n\nI gave Microsoft Bing the following prompt to see if it could replicate some of my work:\n“Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.”\nInitally, it gave me the following code:\nmodule led_blinker_2hz (\n    output logic led\n);\n\n    // Internal oscillator output\n    logic clk;\n    logic clk_en;\n\n    // Instantiate the high-frequency oscillator (typically 48 MHz)\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\")  // No division: 48 MHz\n    ) hf_osc_inst (\n        .CLKHFEN(clk_en),\n        .CLKHFPU(clk_en),\n        .CLKHF(clk)\n    );\n\n    // Enable the oscillator\n    initial clk_en = 1'b1;\n\n    // Counter to divide 48 MHz down to 2 Hz\n    // 48,000,000 / 2 = 24,000,000 clock cycles per toggle\n    localparam int COUNT_MAX = 24_000_000;\n    logic [$clog2(COUNT_MAX)-1:0] counter = 0;\n\n    always_ff @(posedge clk) begin\n        if (counter == COUNT_MAX - 1) begin\n            counter &lt;= 0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\nThis did not synthesize since it used a different clock generator module, SB_HFOSC. When I asked it to correct the error, it insisted that it was related to a missing package. However, once I changed this module to HSOSC, it synthesized just fine.\nThis prototype made me question the landscape of digital design. It seems that these models have gotten very good at the big picture, and only now struggle with the software specific details."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Getting Started\n\n\nFirst Steps into E155\n\n\n\n\n\nAug 29, 2025\n\n\nCorey Hickson\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Corey Hickson is a class of 2026 Engineering Major at Harvey Mudd College with background in design verification and digital design. As a VLSI research fellow with the Clay-Wolkin Fellowship at Harvey Mudd, he has conducted core level functional testing and coverage collection of a RISC-V processor core. While interning at Skyworks Solutions in the summer of 2025, he conducted whole core level formal verification of a different RISC-V processor core. Corey looks forward to the 2025-26 HRL Laboratories engineering clinic project, where he and his team will work towards producing a C program to emulate a mixed analog-digital quantum qubit control board. After graduation, he will return to Skyworks as a Design Verification Engineer 1 to continue his work in formal verification from the past summer."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Getting Started",
    "section": "",
    "text": "This week we had the first 2 lectures for E155, covering course logistics and (System)Verilog syntax and idioms. I was especially exited to cover Verilog since I have become extremely familliar with the subtleties of the Language Reference Manual (LRM) over the past few months (especially the verification specific constructs)."
  },
  {
    "objectID": "posts/first-post.html#week-1-lectures",
    "href": "posts/first-post.html#week-1-lectures",
    "title": "Getting Started",
    "section": "",
    "text": "This week we had the first 2 lectures for E155, covering course logistics and (System)Verilog syntax and idioms. I was especially exited to cover Verilog since I have become extremely familliar with the subtleties of the Language Reference Manual (LRM) over the past few months (especially the verification specific constructs)."
  },
  {
    "objectID": "posts/first-post.html#in-the-lab",
    "href": "posts/first-post.html#in-the-lab",
    "title": "Getting Started",
    "section": "In the Lab",
    "text": "In the Lab\nWhile there were no technical deliverables for this week, I still spent a few hours in the lab soldering all components and connectors to the PCB motherboard. I am not the most skilled at soldering, and I did not have previous experience with surface mounted soldering so this was a bit of a challenge. After much slouching, a considerable amount of solder wick, and a few backwards idodes, I have now finished this task and can move onto lab 1!"
  },
  {
    "objectID": "posts/first-post.html#goal-setting",
    "href": "posts/first-post.html#goal-setting",
    "title": "Getting Started",
    "section": "Goal Setting",
    "text": "Goal Setting\nI am extremely excited to take this class, as I wanted to take it sooner but did not have the time in my schedule. My primary goal is to expand my scope as an electrical engineer beyone ASIC RTL and DV, and into the realm of embedded systems. My secondary goal is to have fun with this class and enjoy my final year at Mudd. I really enjoyed E80 and the E85 microprocessor based labs, so I know that I will enjoy this course now that I have the chance to take it."
  }
]